・（大規模）システム設計とは？
　・スケーラブルなシステム
　　・スケーラブルとは？
　　　・「拡大縮小しやすい」こと
　　　・大きな変更を加えることなく、システムの増強や縮小を滞りなく行えることを指す
　　→完成したあとでも、顧客の要望や状況によってシステムの拡縮を執り行えるシステムを設計すること
　・最近、クラウドが流行しているのは、システムの拡縮をソフトウェアレベルで設計・実装できることが強み

（このドキュメントではテック企業で受ける設計技術面接に対応する教科書として用意されている）
システムの背景を質問して聞き出す（要件定義）
１）誰がシステムを使うのか？（ユーザ想定）
　・対象ユーザ
　　・BtoB？
　　・BtoC？
　　・BtoBtoC？
　　・CtoC？
２）どのようにシステムを使うのか？（ユーザ想定）
　・処理の優先順位がわかる
　・汎用の端末を介して？
　　・ブラウザを介して？
　　・（スマホ・タブレット）アプリを介して？
　・専用の端末・装置を介して？
　　・IoT機器を介して
　・権限管理
　　・RBAC: Role-Based Access Control
　　　・ユーザーの役割によって権限のチェックを行う
　　　　・一般ユーザ、管理者など
　　　　・メリット；権限を変更するだけで処理を変えることができる
　　　　・デメリット：権限が増えると管理や実装が難しくなる
　　・ABAC: Attribute-Based Access Control
　　　・ユーザーの属性によって権限のチェックを行う
　　　　・メリット：柔軟な権限管理ができる
　　　　・デメリット：権限チェックが増えると、DBアクセスに時間がかかることがある
　　→属性をグルーピングして役割とする
　　　・AWSのIAMはこのような管理方法
　　　　・更に、IAMユーザ視点だけではなくコンポーネント視点での権限・役割も存在する
　　・参考：https://applis.io/posts/how-to-manage-authorization
３）何人のユーザが居るのか？（システムの規模）
　・１００人単位？
　・１万人単位？
４）システムはどのような機能を持つのか？

５）システムの入力と出力は？（
　・IoTを使う？
６）どれだけの容量のデータを捌く必要があるのか？
７）１秒間に何回アクセスが有るのか？（スループットの推定）
　・アクセスが集中する時間帯や時期を確認
　・いちばんアクセスする値（推定）がほしい
　・いちばん空いている値もほしい（拡縮の判断）
８）読み書き比率はいくらなのか（推定値）？
　・

evenly distributes: 均等に分配する

・ハーバードでの動画で語っている項目(参考：https://www.youtube.com/watch?v=-W9F__D3oY4)
　・垂直スケーリング
　・水平スケーリング
　・キャッシング
　・ロードバランシング
　・データベースレプリケーション
　・データベースパーティション
・Le Could Blogで語っている項目(参考：https://www.lecloud.net/tagged/scalability)
　・クローン
　　・ロードバランサの下のサーバはそれぞれ全く同じコード内容（コードベース）、同じ出力ができるのが必須
　　　・ロードバランサはリクエストを均等に割り振るため、どのサーバで処理するのか予測不可能
　　・ユーザ関連データはサーバに置かない。サーバからアクセスできるDBに格納する
　　　・サーバにこれらのデータを置くと整合が必要
　　・セッションは持続可能キャッシュ（Redisとか）を使う
　　　・外部DBを使うよりも反応が良い
　　・RailsだったらCapistranoでクローン時のコードベースを担保
　　・AWSのAIMも同じように担保できるのでクローンに有効
　　・→水平スケーリングの核
　・データベース
　　・データベース設計の肝は「非正規化」
　　　・クエリレベルでの結合をなるべく避ける
　　　　・結合が必要になったらアプリケーションレベルで行う
　　　　・その際には使用するデータをなるべく最適化
　　・それでも遅くなるのでキャッシュを導入
　　　・RedisとかMemcachedとか
　　　　・Redisは柔軟な設計が可能、Memcachedは垂直スケーリングができる
　　　　・参考：https://aws.amazon.com/jp/elasticache/redis-vs-memcached/
　　・NoSQLの導入
　　　・スケーリングに強いシステムに切り替えることも考慮
　　・場合によってはデータベースレプリケーションやデータベースパーティションも考慮
　・キャッシュ
　　・RedisやMemcachedの導入
　　・メモリ内キャッシュが必須、ファイルキャッシュはNG
　　　・ファイルキャッシュを使用すると自動スケーリングやサーバーのクローニングが面倒になる
　　・アプリケーションとデータベースとの間のレイヤーに存在する
　　・アプリを開発するときはまずキャッシュにフェッチ、見つからなかったらDBにアクセス
　　　・メモリ内キャッシュは超高速
　　・キャッシュの持ち方、取り出し方は２種類
　　　・キャッシュされたクエリ
　　　　・キャッシュのキーとしてハッシュバージョンを使用
　　　　・複雑なクエリをキャッシュすると削除しにくくなる
　　　　・セルの中身が変わった時、そのセルに関わるキャッシュを全て削除する必要がある
　　　　　・セルにかかわるキャッシュをすべて洗い出すのが面倒
　　　・キャッシュされたオブジェクト
　　　　・複数のデータを纏めてオブジェクトと認識、キャッシュすれば効率的に
　　　　・キャッシュするオブジェクトの例
　　　　　・セッション（DBには保存しないで！）
　　　　　・ブログデータ
　　　　　・アクティビティストリーム
　　　　　・ユーザーとフレンドの関係
　・非同期
　　・常に時間のかかる処理は非同期で処理する
　　　・#1：リクエストの結果がほぼ固定の場合は、事前に時間のかかる処理を施し、リクエストがあったときに短時間で返す
　　　　・処理を施すタイミングは一定時間の間隔で定期処理を施す
　　　・#2：リクエストの結果が流動的なときや突発的なときは、処理の開始をキューに投げてその旨をユーザーに通知する
　　　　・フロントエンド側では完了をチェックして、完了を受け取ったらユーザーに通知する（結果を返す）
　　　・RabbitMQのチュートリアルは非同期のケーススタディの参考になる
　　　　・メッセージブローカーの一種
　　　　　・システム間の依存性をなくす
　　　　・PtoPにもなるし、Pub/Subもいける
　　　　・他には、ActiveMQ(AmazonMQ)がある。Redisもメッセージブローカーとして使える


・ハイレベルでのトレードオフ
　・パフォーマンス vs スケーラビリティ
　　・パフォーマンスが上がる→処理速度が上がる、もっと大きなデータを捌ける
　　・水平にスケールしていけば、そのぶん処理が最適化されると思っていたら大間違い
　・レイテンシ vs スループット
　　・レイテンシ：何かのタスクを実行する・結果を出すのにかかる時間
　　　・一気に多数のタスクが来ると遅延する可能性がある
　　・スループット：単位時間内にタスクを実行したり結果を出せる回数
　　→スループットを最大化するためにレイテンシをどれだけ受け入れられるか
　　　・レイテンシを極限まで削っても、得られる結果が不十分（情報量が少ない、間違っているなど）では不適当
　　　・しっかりした結果を出せたらスループットは犠牲になってもいいのか？
　　　→そこのバーターが腕の見せ所（具体的にはまだわからない）
　・可用性 vs 一貫性
　　・CAP理論
　　　・C:一貫性（Consistency）
　　　　・すべての読み込みは、最新の書き込みかエラーを受け取る設計
　　　　　・弱い：結果を返すときは最新かどうかはわからない（更新されないときがある）
　　　　　　（memcachedでよく見られる)
　　　　　　→ビデオチャット、マルチプレイヤーゲーム、VoIP
　　　　　・結果整合性：結果を返すときは、タイミング的には最新ではないかもしれないけど、最終的には最新になる
　　　　　　→メールシステム、DNS
　　　　　・強い：結果を返すときは必ず最新を保証する
　　　　　　→ファイルシステム、トランザクションを使うシステム
　　　　・外側から見たデータがすべて同じデータに見える状態に置く設計
　　　　・利点
　　　　　・無駄なデータ変換を噛ませる必要がない
　　　　　・矛盾を生じにくい
　　　　　　・一貫性を損なうモジュールを追加した際にはバグが起こりやすい
　　　　　　　・最新の標準的なライブラリをなるべく使う（流儀に従う）
　　　　　・設計の間違いに気づきやすい
　　　・A:可用性（Availability）
　　　　・受け取る情報が最新という保証がないが、リクエストすれば必ず結果を受け取れる設計
　　　　　・フェイルオーバー
　　　　　　・稼働中にシステムがダウンした際、自動的に待機しているシステムが後を引き継ぐ
　　　　　　・アクティブ・パッシブフェイルオーバー（マスター・スレーブフェイルオーバー）
　　　　　　　・システムを利用している側が周期的に信号をアクティブもしくはパッシブ（スタンバイ）に送る
　　　　　　　・信号が中断された際はパッシブのスタンバイを時、アクティブになる
　　　　　　　　・ダウンタイムが必要
　　　　　　・アクティブ・アクティブフェイルオーバー
　　　　　　　・すべてのシステムが処理を捌く（負荷分散）
　　　　　　　　・問題が起きたシステムはパッシブになる
　　　　　　・ダウンした際にパッシブに共有していないデータが存在するリスクがある
　　　　　・レプリケーション
　　　　　　・主にデータベースで使われる
　　　　　　・マスター側がスレーブ側に最新の情報を伝達して同一を保持する
　　　　　　　・マスタースレーブとスレーブマスター
　　　　・システムの運用を長く続けられる性質
　　　　・データを利用したいときに利用できる状態に置く設計
　　　　　・信頼できるデータを長い間利用できる設計
　　　・P:分断耐性（Partition Tolerance）
　　　　・ネットワークが何らかの原因で分断されてもシステムは正常に動く設計
　　　　　・（詳細がわからないのであとで調べる）
　　　→CAPのうち、完全に同時に達成できるのはせいぜい２つまで（CPとAP）
　　　・ただし、相反している、つまりゼロイチの話ではなく、一貫性を保ちながら可用性を最大限に引き上げる、もしくはその逆はできる
　　　・Pは必ず受け入れる必要がある（ネットワークは絶対の信頼を置けないから）
　　　・CP
　　　　・不可分操作（複数の操作を組み合わせて一つの操作とする）
　　　・AP
　　　　・結果総合性を受け入れるとき、外部エラーが起きても稼働する必要がある時はAPで設計
　　・「一貫性を受け入れる」か、「可用性を受け入れる」か、それが運命の分かれ道
　　　・とはいえ、両方受け入れられないのか？　矛盾しているのか？？？
　　　　→CAPの提唱者も言っているが、CかAかどちらか、というわけではない点に注意すること
