・（大規模）システム設計とは？
　・スケーラブルなシステム
　　・スケーラブルとは？
　　　・「拡大縮小しやすい」こと
　　　・大きな変更を加えることなく、システムの増強や縮小を滞りなく行えることを指す
　　→完成したあとでも、顧客の要望や状況によってシステムの拡縮を執り行えるシステムを設計すること
　・最近、クラウドが流行しているのは、システムの拡縮をソフトウェアレベルで設計・実装できることが強み

（このドキュメントではテック企業で受ける設計技術面接に対応する教科書として用意されている）
システムの背景を質問して聞き出す（要件定義）
１）誰がシステムを使うのか？（ユーザ想定）
　・対象ユーザ
　　・BtoB？
　　・BtoC？
　　・BtoBtoC？
　　・CtoC？
２）どのようにシステムを使うのか？（ユーザ想定）
　・
　・汎用の端末を介して？
　　・ブラウザを介して？
　　・（スマホ・タブレット）アプリを介して？
　・専用の端末・装置を介して？
　　・IoT機器を介して
　・権限管理
　　・RBAC: Role-Based Access Control
　　　・ユーザーの役割によって権限のチェックを行う
　　　　・一般ユーザ、管理者など
　　　　・メリット；権限を変更するだけで処理を変えることができる
　　　　・デメリット：権限が増えると管理や実装が難しくなる
　　・ABAC: Attribute-Based Access Control
　　　・ユーザーの属性によって権限のチェックを行う
　　　　・メリット：柔軟な権限管理ができる
　　　　・デメリット：権限チェックが増えると、DBアクセスに時間がかかることがある
　　→属性をグルーピングして役割とする
　　　・AWSのIAMはこのような管理方法
　　　　・更に、IAMユーザ視点だけではなくコンポーネント視点での権限・役割も存在する
　　・参考：https://applis.io/posts/how-to-manage-authorization
３）何人のユーザが居るのか？（システムの規模）
　・１００人単位？
　・１万人単位？
４）システムはどのような機能を持つのか？

５）システムの入力と出力は？（
　・IoTを使う？
６）どれだけの容量のデータを捌く必要があるのか？
７）１秒間に何回アクセスが有るのか？（スループットの推定）
　・アクセスが集中する時間帯や時期を確認
　・いちばんアクセスする値（推定）がほしい
　・いちばん空いている値もほしい（拡縮の判断）
８）読み書き比率はいくらなのか（推定値）？
　・

evenly distributes: 均等に分配する

・ハーバードでの動画で語っている項目(参考：https://www.youtube.com/watch?v=-W9F__D3oY4)
　・垂直スケーリング
　・水平スケーリング
　・キャッシング
　・ロードバランシング
　・データベースレプリケーション
　・データベースパーティション
・Le Could Blogで語っている項目(参考：https://www.lecloud.net/tagged/scalability)
　・クローン
　　・ロードバランサの下のサーバはそれぞれ全く同じコード内容（コードベース）、同じ出力ができるのが必須
　　　・ロードバランサはリクエストを均等に割り振るため、どのサーバで処理するのか予測不可能
　　・ユーザ関連データはサーバに置かない。サーバからアクセスできるDBに格納する
　　　・サーバにこれらのデータを置くと整合が必要
　　・セッションは持続可能キャッシュ（Redisとか）を使う
　　　・外部DBを使うよりも反応が良い
　　・RailsだったらCapistranoでクローン時のコードベースを担保
　　・AWSのAIMも同じように担保できるのでクローンに有効
　　・→水平スケーリングの核
　・データベース
　　・データベース設計の肝は「非正規化」
　　　・クエリレベルでの結合をなるべく避ける
　　　　・結合が必要になったらアプリケーションレベルで行う
　　　　・その際には使用するデータをなるべく最適化
　　・それでも遅くなるのでキャッシュを導入
　　　・RedisとかMemcachedとか
　　　　・Redisは柔軟な設計が可能、Memcachedは垂直スケーリングができる
　　　　・参考：https://aws.amazon.com/jp/elasticache/redis-vs-memcached/
　　・NoSQLの導入
　　　・スケーリングに強いシステムに切り替えることも考慮
　　・場合によってはデータベースレプリケーションやデータベースパーティションも考慮
　・キャッシュ
　　・RedisやMemcachedの導入
　　・メモリ内キャッシュが必須、ファイルキャッシュはNG
　　　・ファイルキャッシュを使用すると自動スケーリングやサーバーのクローニングが面倒になる
　　・アプリケーションとデータベースとの間のレイヤーに存在する
　　・アプリを開発するときはまずキャッシュにフェッチ、見つからなかったらDBにアクセス
　　　・メモリ内キャッシュは超高速
　　・キャッシュの持ち方、取り出し方は２種類
　　　・キャッシュされたクエリ
　　　　・キャッシュのキーとしてハッシュバージョンを使用
　　　　・複雑なクエリをキャッシュすると削除しにくくなる
　　　　・セルの中身が変わった時、そのセルに関わるキャッシュを全て削除する必要がある
　　　　　・セルにかかわるキャッシュをすべて洗い出すのが面倒
　　　・キャッシュされたオブジェクト
　　　　・複数のデータを纏めてオブジェクトと認識、キャッシュすれば効率的に
　　　　・キャッシュするオブジェクトの例
　　　　　・セッション（DBには保存しないで！）
　　　　　・ブログデータ
　　　　　・アクティビティストリーム
　　　　　・ユーザーとフレンドの関係
　・非同期
　　・常に時間のかかる処理は非同期で処理する
　　　・#1：リクエストの結果がほぼ固定の場合は、事前に時間のかかる処理を施し、リクエストがあったときに短時間で返す
　　　　・処理を施すタイミングは一定時間の間隔で定期処理を施す
　　　・#2：リクエストの結果が流動的なときや突発的なときは、処理の開始をキューに投げてその旨をユーザーに通知する
　　　　・フロントエンド側では完了をチェックして、完了を受け取ったらユーザーに通知する（結果を返す）
　　　・RabbitMQのチュートリアルは非同期のケーススタディの参考になる
　　　　・メッセージブローカーの一種
　　　　　・システム間の依存性をなくす
　　　　・PtoPにもなるし、Pub/Subもいける
　　　　・他には、ActiveMQ(AmazonMQ)がある。Redisもメッセージブローカーとして使える


・ハイレベルでのトレードオフ
　・パフォーマンス vs スケーラビリティ
　・レイテンシ vs スループット
　・可用性 vs 一貫性
