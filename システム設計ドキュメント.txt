・(大規模)システム設計とは？
　・スケーラブルなシステム
　　・スケーラブルとは？
　　　・「拡大縮小しやすい」こと
　　　・大きな変更を加えることなく、システムの増強や縮小を滞りなく行えることを指す
　　→完成したあとでも、顧客の要望や状況によってシステムの拡縮を執り行えるシステムを設計すること
　・最近、クラウドが流行しているのは、システムの拡縮をソフトウェアレベルで設計・実装できることが強み

(このドキュメントではテック企業で受ける設計技術面接に対応する教科書として用意されている)
システムの背景を質問して聞き出す(要件定義)
1)誰がシステムを使うのか？(ユーザ想定)
　・対象ユーザ
　　・BtoB？
　　・BtoC？
　　・BtoBtoC？
　　・CtoC？
2)どのようにシステムを使うのか？(ユーザ想定)
　・処理の優先順位がわかる
　・汎用の端末を介して？
　　・ブラウザを介して？
　　・(スマホ・タブレット)アプリを介して？
　・専用の端末・装置を介して？
　　・IoT機器を介して
　・権限管理
　　・RBAC: Role-Based Access Control
　　　・ユーザーの役割によって権限のチェックを行う
　　　　・一般ユーザ、管理者など
　　　　・メリット；権限を変更するだけで処理を変えることができる
　　　　・デメリット：権限が増えると管理や実装が難しくなる
　　・ABAC: Attribute-Based Access Control
　　　・ユーザーの属性によって権限のチェックを行う
　　　　・メリット：柔軟な権限管理ができる
　　　　・デメリット：権限チェックが増えると、DBアクセスに時間がかかることがある
　　→属性をグルーピングして役割とする
　　　・AWSのIAMはこのような管理方法
　　　　・更に、IAMユーザ視点だけではなくコンポーネント視点での権限・役割も存在する
　　・https://applis.io/posts/how-to-manage-authorization
3)何人のユーザが居るのか？(システムの規模)
　・100人単位？
　・1万人単位？
4)システムはどのような機能を持つのか？
　・(あとで書く)
5)システムの入力と出力は？(
　・IoTを使う？
6)どれだけの容量のデータを捌く必要があるのか？
7)1秒間に何回アクセスが有るのか？(スループットの推定)
　・アクセスが集中する時間帯や時期を確認
　・いちばんアクセスする値(推定)がほしい
　・いちばん空いている値もほしい(拡縮の判断)
8)読み書き比率はいくらなのか(推定値)？
　・(あとで書く)

・ハーバードでの動画で語っている項目(https://www.youtube.com/watch?v=-W9F__D3oY4)
　・垂直スケーリング
　・水平スケーリング
　・キャッシング
　・ロードバランシング
　・データベースレプリケーション
　・データベースパーティション
・Le Could Blogで語っている項目(https://www.lecloud.net/tagged/scalability)
　・クローン
　　・ロードバランサの下のサーバはそれぞれ全く同じコード内容(コードベース)、同じ出力ができるのが必須
　　　・ロードバランサはリクエストを均等に割り振るため、どのサーバで処理するのか予測不可能
　　・ユーザ関連データはサーバに置かない。サーバからアクセスできるDBに格納する
　　　・サーバにこれらのデータを置くと整合が必要
　　・セッションは持続可能キャッシュ(Redisとか)を使う
　　　・外部DBを使うよりも反応が良い
　　・RailsだったらCapistranoでクローン時のコードベースを担保
　　・AWSのAIMも同じように担保できるのでクローンに有効
　　・→水平スケーリングの核
　・データベース
　　・データベース設計の肝は「非正規化」
　　　・クエリレベルでの結合をなるべく避ける
　　　　・結合が必要になったらアプリケーションレベルで行う
　　　　・その際には使用するデータをなるべく最適化
　　・それでも遅くなるのでキャッシュを導入
　　　・RedisとかMemcachedとか
　　　　・Redisは柔軟な設計が可能、Memcachedは垂直スケーリングができる
　　　　・https://aws.amazon.com/jp/elasticache/redis-vs-memcached/
　　・NoSQLの導入
　　　・スケーリングに強いシステムに切り替えることも考慮
　　・場合によってはデータベースレプリケーションやデータベースパーティションも考慮
　・キャッシュ
　　・RedisやMemcachedの導入
　　・メモリ内キャッシュが必須、ファイルキャッシュはNG
　　　・ファイルキャッシュを使用すると自動スケーリングやサーバーのクローニングが面倒になる
　　・アプリケーションとデータベースとの間のレイヤーに存在する
　　・アプリを開発するときはまずキャッシュにフェッチ、見つからなかったらDBにアクセス
　　　・メモリ内キャッシュは超高速
　　・キャッシュの持ち方、取り出し方は２種類
　　　・キャッシュされたクエリ
　　　　・キャッシュのキーとしてハッシュバージョンを使用
　　　　・複雑なクエリをキャッシュすると削除しにくくなる
　　　　・セルの中身が変わった時、そのセルに関わるキャッシュを全て削除する必要がある
　　　　　・セルにかかわるキャッシュをすべて洗い出すのが面倒
　　　・キャッシュされたオブジェクト
　　　　・複数のデータを纏めてオブジェクトと認識、キャッシュすれば効率的に
　　　　・キャッシュするオブジェクトの例
　　　　　・セッション(DBには保存しないで！)
　　　　　・ブログデータ
　　　　　・アクティビティストリーム
　　　　　・ユーザーとフレンドの関係
　・非同期
　　・常に時間のかかる処理は非同期で処理する
　　　・#1：リクエストの結果がほぼ固定の場合は、事前に時間のかかる処理を施し、リクエストがあったときに短時間で返す
　　　　・処理を施すタイミングは一定時間の間隔で定期処理を施す
　　　・#2：リクエストの結果が流動的なときや突発的なときは、処理の開始をキューに投げてその旨をユーザーに通知する
　　　　・フロントエンド側では完了をチェックして、完了を受け取ったらユーザーに通知する(結果を返す)
　　　・RabbitMQのチュートリアルは非同期のケーススタディの参考になる
　　　　・メッセージブローカーの一種
　　　　　・システム間の依存性をなくす
　　　　・PtoPにもなるし、Pub/Subもいける
　　　　・他には、ActiveMQ(AmazonMQ)がある。Redisもメッセージブローカーとして使える

・ハイレベルでのトレードオフ
　・パフォーマンス vs スケーラビリティ
　　・パフォーマンスが上がる→処理速度が上がる、もっと大きなデータを捌ける
　　・水平にスケールしていけば、そのぶん処理が最適化されると思っていたら大間違い
　・レイテンシ vs スループット
　　・レイテンシ：何かのタスクを実行する・結果を出すのにかかる時間
　　　・一気に多数のタスクが来ると遅延する可能性がある
　　・スループット：単位時間内にタスクを実行したり結果を出せる回数
　　→スループットを最大化するためにレイテンシをどれだけ受け入れられるか
　　　・レイテンシを極限まで削っても、得られる結果が不十分(情報量が少ない、間違っているなど)では不適当
　　　・しっかりした結果を出せたらスループットは犠牲になってもいいのか？
　　　→そこのバーターが腕の見せ所(具体的にはまだわからない)
　・可用性 vs 一貫性
　　・CAP理論
　　　・CAPのうち、完全に同時に達成できるのはせいぜい２つまで(CPとAP)
　　　　・ただし、相反している、つまりゼロイチの話ではなく、一貫性を保ちながら可用性を最大限に引き上げる、もしくはその逆はできる
　　　　・Pは必ず受け入れる必要がある(ネットワークは絶対の信頼を置けないから)
　　　　・CP
　　　　　・不可分操作(複数の操作を組み合わせて一つの操作とする)
　　　　・AP
　　　　　・結果総合性を受け入れるとき、外部エラーが起きても稼働する必要がある時はAPで設計
　　　　・「一貫性を受け入れる」か、「可用性を受け入れる」か、それが運命の分かれ道
　　　　・とはいえ、両方受け入れられないのか？　矛盾しているのか？？？
　　　　　→CAPの提唱者も言っているが、CとAのどちらに全振りするか、という極端な話ではない点に注意すること
　　　・イメージではデータベースがメジャー
　　　・C:一貫性(Consistency)
　　　　・すべての読み込みは、最新の書き込みかエラーを受け取る設計
　　　　　・弱い：結果を返すときは最新かどうかはわからない(更新されないときがある)
　　　　　　(memcachedでよく見られる)
　　　　　　→ビデオチャット、マルチプレイヤーゲーム、VoIP
　　　　　・結果整合性：結果を返すときは、タイミング的には最新ではないかもしれないけど、最終的には最新になる
　　　　　　→メールシステム、DNS
　　　　　・強い：結果を返すときは必ず最新を保証する
　　　　　　→ファイルシステム、トランザクションを使うシステム
　　　　・外側から見たデータがすべて同じデータに見える状態に置く設計
　　　　・利点
　　　　　・無駄なデータ変換を噛ませる必要がない
　　　　　・矛盾を生じにくい
　　　　　　・一貫性を損なうモジュールを追加した際にはバグが起こりやすい
　　　　　　　・最新の標準的なライブラリをなるべく使う(流儀に従う)
　　　　　・設計の間違いに気づきやすい
　　　　・Mongoの単一マスター制
　　　・A:可用性(Availability)
　　　　・受け取る情報が最新という保証がないが、リクエストすれば必ず結果を受け取れる設計
　　　　　・フェイルオーバー
　　　　　　・稼働中にシステムがダウンした際、自動的に待機しているシステムが後を引き継ぐ
　　　　　　・アクティブ・パッシブフェイルオーバー(マスター・スレーブフェイルオーバー)
　　　　　　　・システムを利用している側が周期的に信号をアクティブもしくはパッシブ(スタンバイ)に送る
　　　　　　　・信号が中断された際はパッシブのスタンバイを時、アクティブになる
　　　　　　　　・ダウンタイムが必要
　　　　　　・アクティブ・アクティブフェイルオーバー
　　　　　　　・すべてのシステムが処理を捌く(負荷分散)
　　　　　　　　・問題が起きたシステムはパッシブになる
　　　　　　・ダウンした際にパッシブに共有していないデータが存在するリスクがある
　　　　　・レプリケーション
　　　　　　・主にデータベースで使われる
　　　　　　・マスター側がスレーブ側に最新の情報を伝達して同一を保持する
　　　　　　　・マスタースレーブとスレーブマスター
　　　　・システムの運用を長く続けられる性質
　　　　・データを利用したいときに利用できる状態に置く設計
　　　　　・信頼できるデータを長い間利用できる設計
　　　　・Cassandraはすべてアクティブ(アクティブ・アクティブフェイルオーバー)
　　　・P:分断耐性(Partition Tolerance)
　　　　・ネットワークが何らかの原因で分断されてもシステムは正常に動く設計
　　　　　・分断されたほうにあるシステムにリクエストが行かないよう確実に遮断する設計
　・BASE理論
　　・CAPの弱点を補う形でデータの整合性を取る理論
　　・BA:Basically Available(基本的な可用性)
　　　・楽観ロック
　　　　・同時にデータを更新するのは無いだろうという楽観的な視点で対応する
　　　　　・自分さえ良ければそれでいい的なイメージ
　　　　　・更新する際は、更新前の値が取得時の値が変わって居ないかどうかを確認するだけのロック
　　　　　→悲観ロックは、誰かがアクセスしている間更新できないロック
　　　　　・一人はみんなのために
　　　・キュー
　　　　・(略)
　　・S:Soft-State(耐久性のない状態保持)
　　　・状態→データの状態
　　　・データが消える可能性がある
　　　・データの保証は外部データを使用
　　　　・Hard-Stateのデータを取ってくる
　　　　・Hard-State(耐久性のある状態保持)は、ファイルなどが挙げられる
　　　・キャッシュがまさにそれ
　　・E:Eventually Consistent(結果整合性)
　　　・既出なので略
　　・トランザクションには向かない
　　　・ACID特性(後述)遵守
　・ACID特性
　　・トランザクション処理における絶対不可欠な要素４種類の頭文字
　　　・A:不可分性(Atomicity)
　　　　・実行対象が完全に結果を残す(全く結果を残さない)ことを保証する
　　　　・確実にCommitかRollbackされる
　　　　・中途半端に結果を残さない
　　　・C:一貫性(Consistency)
　　　　・既出なので略
　　　・I:独立性(Isolation)
　　　　・「分離性」とも。トランザクション分離レベルとも微妙に関連
　　　　・トランザクション実行中に他のリクエストがデータにアクセスしない(分離する)ことを保証する
　　　　　・分離レベルは設定可能だが、パフォーマンスに影響が出る
　　　　　・テーブル自体をロックする方法も検討する
　　　　　・不用意なロック設計によるデッドロックに注意！
　　　　・リード現象(Read Phenomena)
　　　　　・Dirty Read
　　　　　　・トランザクション実行中に、別トランザクションが更新している(未Commit)のデータを読み込める
　　　　　・Fuzzy Read(Non-Repeatable Read)
　　　　　　・繰り返し同じデータを読み込むトランザクション実行中に、別トランザクションが更新・Commitした値を読み取る
　　　　　・Fantom Read
　　　　　　・トランザクション実行中に、別のトランザクションがデータを追加・Commitして変更された値を読み取る
　　　　　・Lost Update
　　　　　　・トランザクションが更新したデータを、別のトランザクションが更新したために更新がなかったことにされた
　　　　・分離レベル(ANSI)
　　　　　・read uncommitted
　　　　　　・未Commitのデータでも読み込める
　　　　　　・処理は早くなるが、Dirty Readのリスクは高い
　　　　　・read committed
　　　　　　・更新されたCommitのみ参照できる
　　　　　　　・最後に更新Commitした値を参照する
　　　　　　・追加・削除に関しては未Commitのデータも参照できる
　　　　　　　・Dirty Readは解消できるがFuzzy ReadやFantom Readは対処できない
　　　　　　・PostgreSQL,SQLServerでの標準分離レベル
　　　　　・repeatable read
　　　　　　・Commitされた更新・追加・削除のデータのみ参照できる
　　　　　　　・トランザクション中に同じ参照をした際は、最後にCommitしたデータを参照する
　　　　　　　　・整合性が取れるが一貫性は担保できない
　　　　　　・Fuzzy Read・Fantom Readも解消できるが、Lost Updateは流石に対策しないと避けられない
　　　　　　・MySQLでの標準分離レベル
　　　　　・serializable
　　　　　　・強制的にトランザクションの順番をつけて、同時実行をさせないようにする
　　　　　　・Lost Updateもなくなるが、スループットは大幅に悪くなる
　　　　　・IBM DB2には「カーソル固定」というものがある
　　　・D:永続性(Durability)
　　　　・障害によって起きるデータの損失を出さないようにする
　　　　　・まずはインフラ側で障害をおこなさないようにするのはマストだが、どうしようもない時があることは受け入れる
　　　　　・ログが取れなかったときのリスクも検討する
　　　　・トランザクション・クエリのログを取っておく
　　　　　・障害が起きて消えたデータをそのログで復帰させる
