# 大規模システム設計メモ（「システム設計入門」を読んで考える）

[C]2022 Cyross Makoto

---

## 前提

このドキュメントではテック企業で受ける設計技術面接に対応する教科書として用意されている

## (大規模)システム設計とは？

* 「**スケーラブルなシステム**」を設計すること

### スケーラブルとは？

* システムの規模を**拡大縮小しやすい**こと
  * 大きな変更を加えることなく、システムの増強や縮小を滞りなく行えることを指す
    * 完成したあとでも、顧客の要望や状況によってシステムの拡縮を執り行えるシステムを設計すること
  * 最近、クラウドが流行しているのは、システムの拡縮をソフトウェアレベルで設計・実装できることが強み

## スケーラブルを実現するために想定することと聞き出すこと

システムの背景を質問して聞き出す(要件定義)

### 1.誰がシステムを使うのか？(ユーザ想定)

* 対象ユーザ
  * BtoB？
  * BtoC？
  * BtoBtoC？
  * CtoC？

### 2.どのようにシステムを使うのか？(ユーザ想定)

* 処理の優先順位がわかる
* 汎用の端末を介して？
  * ブラウザを介して？
    * (スマホ・タブレット)アプリを介して？
  * 専用の端末・装置を介して？
    * IoT機器を介して
  * 権限管理
    * RBAC: Role-Based Access Control
      * ユーザーの役割によって権限のチェックを行う
        * 一般ユーザ、管理者など
        * メリット；権限を変更するだけで処理を変えることができる
        * デメリット：権限が増えると管理や実装が難しくなる
    * ABAC: Attribute-Based Access Control
      * ユーザーの属性によって権限のチェックを行う
      * メリット：柔軟な権限管理ができる
      * デメリット：権限チェックが増えると、DBアクセスに時間がかかることがある
　　→属性をグルーピングして役割とする
　　　・AWSのIAMはこのような管理方法
　　　　・更に、IAMユーザ視点だけではなくコンポーネント視点での権限・役割も存在する
　　・[参考リンク](https://applis.io/posts/how-to-manage-authorization)

### 3.何人のユーザが居るのか？(システムの規模)

* 100人単位？
* 1万人単位？

### 4.システムはどのような機能を持つのか？

* (あとで書く)

### 5. システムの入力と出力は？(

* IoTを使う？

### 6. どれだけの容量のデータを捌く必要があるのか？

### 7. 1秒間に何回アクセスが有るのか？(スループットの推定)

* アクセスが集中する時間帯や時期を確認
* いちばんアクセスする値(推定)がほしい
* いちばん空いている値もほしい(拡縮の判断)

### 8. 読み書き比率はいくらなのか(推定値)？

* (あとで書く)

## おさらい

### 動画でおさらい

[ハーバード大学の講義の動画(英語)](https://www.youtube.com/watch?v=-W9F__D3oY4)

#### 動画で語られている項目

* 垂直スケーリング
* 水平スケーリング
* キャッシング
* ロードバランシング
* データベースレプリケーション
* データベースパーティション

### ブログ記事でおさらい

[Le Could Blogのscalabilityタグ](https://www.lecloud.net/tagged/scalability)

#### ブログで語られている項目

詳細はリンク先にて

* [クローン](#ブログの項目クローン)
* [データベース](#ブログの項目データベース)
* [キャッシュ](#ブログの項目キャッシュ)
* [非同期](#ブログの項目非同期)

##### ブログの項目：クローン

* ロードバランサの下のサーバはそれぞれ全く同じコード内容(コードベース)、同じ出力ができるのが必須
* ロードバランサはリクエストを均等に割り振るため、どのサーバで処理するのか予測不可能
  * ユーザ関連データはサーバに置かない。サーバからアクセスできるDBに格納する
    * サーバにこれらのデータを置くと整合が必要
* セッションは持続可能キャッシュ(Redisとか)を使う
  * 外部DBを使うよりも反応が良い
* RailsだったらCapistranoでクローン時のコードベースを担保
  * AWSのAIMも同じように担保できるのでクローンに有効
  * 水平スケーリングの核

##### ブログの項目：データベース

* データベース設計の肝は「非正規化」
  * クエリレベルでの結合をなるべく避ける
  * 結合が必要になったらアプリケーションレベルで行う
    * その際には使用するデータをなるべく最適化
  * 更に規模が大きくなると、それでも遅くなるのでキャッシュを導入
    * RedisとかMemcachedとか
    * Redisは柔軟な設計が可能、Memcachedは垂直スケーリングができる
    * [参考:AWS公式のRedis・Memcached比較ページ](https://aws.amazon.com/jp/elasticache/redis-vs-memcached/)
  * NoSQLの導入
    * スケーリングに強いシステムに切り替えることも考慮
* 場合によってはデータベースレプリケーションやデータベースパーティションも考慮

##### ブログの項目：キャッシュ

* RedisやMemcachedの導入
  * メモリ内キャッシュが必須、ファイルキャッシュはNG
    * ファイルキャッシュを使用すると自動スケーリングやサーバーのクローニングが面倒になる
    * アプリケーションとデータベースとの間のレイヤーに存在する
    * アプリを開発するときはまずキャッシュにフェッチ、見つからなかったらDBにアクセス
  * メモリ内キャッシュは超高速
  * キャッシュの持ち方、取り出し方は２種類
  * キャッシュされたクエリ
    * キャッシュのキーとしてハッシュバージョンを使用
    * 複雑なクエリをキャッシュすると削除しにくくなる
      * セルの中身が変わった時、そのセルに関わるキャッシュを全て削除する必要がある
        * セルにかかわるキャッシュをすべて洗い出すのが面倒
  * キャッシュされたオブジェクト
    * 複数のデータを纏めてオブジェクトと認識、キャッシュすれば効率的に
    * キャッシュするオブジェクトの例
      * セッション(DBには保存しないで！)
      * ブログデータ
      * アクティビティストリーム
      * ユーザーとフレンドの関係

##### ブログの項目：非同期

* 常に時間のかかる処理は非同期で処理する
  * #1：リクエストの結果がほぼ固定の場合は、事前に時間のかかる処理を施し、リクエストがあったときに短時間で返す
    * 処理を施すタイミングは一定時間の間隔で定期処理を施す
  * #2：リクエストの結果が流動的なときや突発的なときは、処理の開始をキューに投げてその旨をユーザーに通知する
    * フロントエンド側では完了をチェックして、完了を受け取ったらユーザーに通知する(結果を返す)
    * RabbitMQのチュートリアルは非同期のケーススタディの参考になる
    * メッセージブローカーの一種
      * システム間の依存性をなくす
    * PtoPにもなるし、Pub/Subもいける
    * 他には、ActiveMQ(AmazonMQ)がある。Redisもメッセージブローカーとして使える

## ハイレベルでのトレードオフ

### トレードオフのパターン

パターンとして以下の３つがある

* [パフォーマンス vs スケーラビリティ](#パフォーマンス-vs-スケーラビリティ)
* [レイテンシ vs スループット](レイテンシ-vs-スループット)
* [可用性 vs 一貫性](可用性-vs-一貫性)

### パフォーマンス vs スケーラビリティ

* パフォーマンスが上がる→処理速度が上がる、もっと大きなデータを捌ける
* 水平にスケールしていけば、そのぶん処理が最適化されると思っていたら大間違い

### レイテンシ vs スループット

#### レイテンシ

何かのタスクを実行する・結果を出すのにかかる時間

一気に多数のタスクが来ると遅延する可能性がある

#### スループット

単位時間内にタスクを実行したり結果を出せる回数

#### レイテンシとスループットとの駆け引き

スループットを最大化するためにレイテンシをどれだけ受け入れられるか

* レイテンシを極限まで削っても、得られる結果が不十分(情報量が少ない、間違っているなど)では不適当
* しっかりした結果を出せたらスループットは犠牲になってもいいのか？
* そこのバーターが腕の見せ所

### 可用性 vs 一貫性

#### CAP理論

システムを設計する方向性を検討する際、以下の3つのうち、せいぜい2つまでしか担保できないという理論

* [一貫性(Consistency)](#cap理論一貫性)
* [可用性(Availability)](#cap理論可用性)
* [分断耐性(Partition tolerance)](#cap理論分断耐性)

##### CAP理論：一貫性

すべての読み込みは、最新の書き込みかエラーを受け取る設計
外側から見たデータがすべて同じデータに見える状態に置く設計

一貫性は結果の新しさに応じて強さを決める

* **弱い**：結果を返すときは最新かどうかはわからない(更新されないときがある)
  * memcachedでよく見られる
  * 例: ビデオチャット、マルチプレイヤーゲーム、VoIP
* **結果整合性**：結果を返すときは、タイミング的には最新ではないかもしれないけど、最終的には最新になる
  * 例: メールシステム、DNS
* **強い**：結果を返すときは必ず最新を保証する
  * 例: ファイルシステム、トランザクションを使うシステム
  * 補足として、ACID特性も追記した(後述)

###### 一貫性の利点

* 無駄なデータ変換を噛ませる必要がない
* 矛盾を生じにくい
  * 一貫性を損なうモジュールを追加した際にはバグが起こりやすい
  * 最新の標準的なライブラリをなるべく使う(流儀に従う)
* 設計の間違いに気づきやすい

##### CAP理論：可用性

受け取る情報が最新という保証がないが、リクエストすれば必ず結果を受け取れる設計。もしくは、データを利用したいときに利用できる状態に置く設計（信頼できるデータを長い間利用できる設計）
こうすることで、システムの運用を長く続けられる性質。

###### フェイルオーバー

稼働中にシステムがダウンした際、自動的に待機しているシステムが後を引き継ぐ仕組み

フェイルオーバーを考慮したシステムの構成は以下の2パターンがある

* **アクティブ・パッシブフェイルオーバー(マスター・スレーブフェイルオーバー)**
  * システムを利用している側が周期的に信号をアクティブもしくはパッシブ(スタンバイ)に送る
  * 信号が中断された際はパッシブのスタンバイを時、アクティブになる
    * ダウンタイムが必要
  * 例: MongoDBの単一マスター制により、分散されているDB上のデータはすべて最新

* **アクティブ・アクティブフェイルオーバー**
  * すべてのシステムが処理を捌く(負荷分散)
  * 問題が起きたシステムはパッシブになる
    * ダウンした際にパッシブに共有していないデータが存在するリスクがある
  * 例: Cassandraはすべてアクティブ(アクティブ・アクティブフェイルオーバー)

###### レプリケーション

マスター側がスレーブ側に最新の情報を伝達して同一を保持する仕組み

##### CAP理論：分断耐性

ネットワークが何らかの原因で分断されてもシステムは正常に動く設計。つまり、分断されたほうにあるシステムにリクエストが行かないよう確実に遮断する設計

##### 完全に達成できる組み合わせ

CAPのうち、完全に同時に達成できるのはせいぜい２つまでで、その組み合わせは**CP**と**AP**のみ。
Pは必ず受け入れる必要がある(ネットワークは絶対の信頼を置けないから)

* **CP**: 不可分操作(複数の操作を組み合わせて一つの操作とする)
* **AP**: 結果総合性を受け入れるとき、外部エラーが起きても稼働する必要がある時はAPで設計

**注**: ただし、相反している、つまりゼロイチの話ではなく、一貫性を保ちながら可用性を最大限に引き上げる、もしくはその逆はできる

* 「一貫性を受け入れる」か、「可用性を受け入れる」か、それが運命の分かれ道
* とはいえ、両方受け入れられないのか？　矛盾しているのか？？？
  * 弱点を補強するBASE理論が提唱された(後述)
* CAPの提唱者も言っているが、CとAのどちらに全振りするか、という極端な話ではない点に注意すること

#### 補足1: BASE理論

CAPの弱点を補う形でデータの整合性を取る理論
以下の3要素を採用している

* [基本的な可用性(Basically Available)](#base理論基本的な可用性)
* [耐久性のない状態保持(Soft-State)](#base理論耐久性のない状態保持)
* [結果整合性(Eventually Consistent)](#base理論結果整合性)

他のリクエストに影響を出さないように務めるトランザクションには向かない(後述するACID特性を遵守するため)

##### BASE理論：基本的な可用性

可用性を考える時、フェイルセーフなどを用いることになるが、基本的なもので賄うことで可用性を担保する

###### 楽観ロック

同時にデータを更新するのは無いだろうという楽観的な視点で対応する(自分さえ良ければそれでいい的なイメージ)

更新する際は、更新前の値が取得時の値と変わって居ないかどうかを確認するだけで、データが追加されたり、実際に他のリクエストがデータにアクセスしていないことを考慮しない。

逆に、悲観ロックは、誰かがアクセスしている間更新できないロック

###### キュー

(略)

##### BASE理論：耐久性のない状態保持

いつリクエストしてもそこにデータが存在しているわけではなく、時と場合によっては存在していない
ちなみに、状態とは**データの状態**を指す

外部データを使用することで保証する

外部データはHard-State(耐久性のある状態保持、ファイルなど)のシステムがマスト

Soft-Stateの例としては、キャッシュがまさにそれ

##### BASE理論：結果整合性

結果を返すときは、タイミング的には最新ではないかもしれないけど、最終的には最新になる

例: メールシステム、DNS

#### 補足2:ACID特性

トランザクション処理における絶対不可欠な要素４種類の頭文字を指す

* [不可分性(Atomicity)](#acid特性不可分性)
* [一貫性(Consistency)](#acid特性一貫性)
* [独立性(Isolation)](#acid特性独立性)
* [永続性(Durability)](#acid特性永続性)

一貫性は既出なので省略する

##### ACID特性：不可分性

実行対象が完全に結果を残す(全く結果を残さない)ことを保証する

* 確実にCommitかRollbackされる
* 中途半端に結果を残さない

##### ACID特性：一貫性

すべての読み込みは、最新の書き込みかエラーを受け取る設計
外側から見たデータがすべて同じデータに見える状態に置く設計

一貫性は結果の新しさに応じて強さを決める

* **弱い**：結果を返すときは最新かどうかはわからない(更新されないときがある)
  * memcachedでよく見られる
  * 例: ビデオチャット、マルチプレイヤーゲーム、VoIP
* **結果整合性**：結果を返すときは、タイミング的には最新ではないかもしれないけど、最終的には最新になる
  * 例: メールシステム、DNS
* **強い**：結果を返すときは必ず最新を保証する
  * 例: ファイルシステム、トランザクションを使うシステム

##### ACID特性：独立性

トランザクション実行中に他のリクエストがデータへアクセスに制限を設ける(分離する)ことを保証すること
アクセス制限の度合いは設定可能(分離レベル)。ただし、強力なものになるにつれてパフォーマンスに影響が出たり、デッドロックが発生することに注意。
(ちなみに、テーブル自体をロックする方法も検討する)

* 複数のトランザクションが同時に実行した結果は、一つずつ順番に実行したものと同じになる

###### リード現象(Read Phenomena)

トランザクション実行時のデータ整合性の問題が生まれる。これをリード現象(Read Phenomena)と呼ぶ。これは分離レベルを用いることでこれらの現象を解決できる。

* **Dirty Read**

トランザクション実行中に、別トランザクションが更新している(未Commit)のデータを読み込める

* **Fuzzy Read(Non-Repeatable Read)**

繰り返し同じデータを読み込むトランザクション実行中に、別トランザクションが更新・Commitした値を読み取る

* **Fantom Read**

トランザクション実行中に、別のトランザクションがデータを追加・Commitして変更された値を読み取る

* **Lost Update**

トランザクションが更新したデータを、別のトランザクションが更新したために更新がなかったことにされた

###### 分離レベル

分離レベルの例としてANSIが制定しているものを解説していく
設定によって解決できるリード現象の範囲が違う

* **read uncommitted**

未Commitのデータでも読み込める。
処理は早くなるが、Dirty Readのリスクは高い。

* **read committed**

更新されたCommitのみ参照できる(最後に更新Commitした値を参照する)。ただし、追加・削除に関しては未Commitのデータも参照できる
Dirty Readは解消できるがFuzzy ReadやFantom Readは対処できない。

PostgreSQL,SQLServerでの標準分離レベル。

* **repeatable read**

Commitされた更新・追加・削除のデータのみ参照できる(トランザクション中に同じ参照をした際は、最後にCommitしたデータを参照する)。
ただし、整合性が取れるが一貫性は担保できない。
Fuzzy Read・Fantom Readも解消できるが、Lost Updateは流石に対策しないと避けられない。

MySQLでの標準分離レベル。

* **serializable**

強制的にトランザクションの順番をつけて、同時実行をさせないようにする。
Lost Updateもなくなるが、スループットは大幅に悪くなる。

* **その他**

IBM DB2には「カーソル固定」というものがある

##### ACID特性：永続性

障害によって起きるデータの損失を出さないようにする。まずはインフラ側で障害をおこなさないようにするのはマストだが、どうしようもない時があることは受け入れる。

ログが取れなかったときのリスクも検討する。
トランザクション・クエリのログを取っておく。
障害が起きて消えたデータをそのログで復帰させる。

### 実例で学ぶトレードオフ

トレードオフの例として、以下のシステムを解説する。

* [DNS(Domain Name System)](#トレードオフ例dns)
* [CDN(Content Delivery Network)](#トレードオフ例cdn)
* [ロードバランサ](#トレードオフ例ロードバランサ)
* [リバースプロキシ(Webサーバー)](#トレードオフ例リバースプロキシ)
  
#### トレードオフ例：DNS

ドメイン名からIPを割り出す。階層構造になっており、下層のDNSはキャシュを用いて高速化を測っている。それゆえ、割り出す組み合わせが変わっているにも関わらず、DNSに反映されていなかったりキャッシュを返したりする時がある。
しかも、キャッシュされていたとしても、やはり取得に少しの時間が必要。

DNSを使用した負荷分散も可能(メリットデメリットが有る)

* **加重ラウンドロビン(重み付きラウンドロビン)**

サーバーの処理能力に応じて、管理者が明示的に「重み」を設定し、その重みに応じた分量を割り振る。
例えば、インスタンスXに80、インスタンスYに20を割り振れば、40個のリクエストのうちXには32個、Yには8個割り振られる。
IPが指しているシステムに障害があったとしても検知できないなどの問題がある。

* **レイテンシベースルーティング**

リクエストのレイテンシを測定して、レイテンシが一番短い地域のIPアドレスを返す方式

* **物理ベースルーティング**

詳細不明

##### DNSの弱点

DNSサーバの管理が複雑(大企業や政府によって管理されている)
更に、DDoS攻撃の標的になる危険性がある(Twitterの障害が例)

##### DNSで登録する内容

* NS record (name server) - あなたのドメイン・サブドメインでのDNSサーバーを特定します。
* MX record (mail exchange) - メッセージを受け取るメールサーバーを特定します。
* A record (address) - IPアドレスに名前をつけます。
* CNAME (canonical) - 他の名前もしくは　CNAME (example.com を www.example.com) もしくは A recordへと名前を指し示す。

#### トレードオフ例：CDN

世界中に設置されたプロキシーサーバーがリクエストしたデータを返す(HTML、CSS、JS、画像、動画などの静的データ)。
特徴的なのは、リクエストした場所から一番近いプロキシーサーバーがデータを返すこと。故に、CDNサーバーが元のサーバーからデータを取得させる必要がある。

例外はAWSのCloudFrontで、動的なデータも提供可能

取得方法は次の2種類

##### プッシュCDN

管理者がすべてのCDNにデータをアップロードし、URLがCDNを指すようにすることで、リクエスト側が最新のデータをすぐに受け取れることを担保する方式（データの責任は管理者に委ねられる）。
データアップロードに手間がかかることと、すべてのCDNにデータが置かれることからストレージの負担も難点

→あまりトラフィック量や更新頻度が低いデータに向いている

##### プルCDN

データ自体は元サーバーに存在し、CDNにリクエストが来る際に元サーバーのデータをキャッシュする方式
CDNが取ってきたデータの有効期間を設定可能
ストレージの無駄は省けるが、初回リクエストのときに時間がかかること、最新のデータの反映が遅くなることが難点

→トラフィック量が多かったり、頻繁に更新されるデータに向いている

##### CDNの弱点

CDNのトラフィック量によってコストが変わる。CDNを使わないときも考慮に入れる必要がある。
また、リクエスト側(HTMLやJS、CSS)側でCDNを明示的に指し示す必要がある。

#### トレードオフ例：ロードバランサ

各サーバーの冗長化のために、ルールに則って複数サーバーに負担を強いることなくリクエストを振り分けるサーバー

##### ロードバランサの特徴

基本的に以下の効果がある。

* リクエストが状態の良くないサーバーに行くのを防ぐ
* リクエストを過剰に送るのを防ぐ
* 特定箇所の欠陥でサービスが落ちることを防ぐ

他にも、SSLを使った暗号化・復号化を肩代わりしたり、セッション管理やコンテンツキャッシュなどの機能を持つサーバーアプリがある。

HAProxyなどを使って実現する。

##### 振り分けのルール

振り分けのルールには以下のものがある。

* **ランダム**
  * どんなリクエストが来ようとも、乱数で行き先を割り振る
* **Least Loaded**
  * 各サーバーが受け持っている処理数を確認して、一番空いているサーバーに割り振る
* **セッション/クッキー**
  * セッションが保存された場合、そのIDでリクエストを割り振る
  * クッキーにセッション情報を組み込むことで維持する
* **ラウンドロビン、加重ラウンドロビン**
  * リクエストの振り分け先を順番に振り分ける
  * 加重ラウンドロビンは既出のため省略
* **Layer4**
  * トランスポート層（OSI参照モデル第4層）の情報をもとに振り分ける
  * リクエストのソースIP、送信先IP、ヘッダのポート番号
* **Layer7**
  * アプリケーション層（OSI参照モデル第7層）の情報をもとに振り分ける
  * リクエストのコンテンツ（ヘッダ、メッセージ、クッキー）、リクエストパラメーター

##### ロードバランサを利用する利点

水平スケーリングする際に、外側からのアクセスへの考慮負担が少なくなる。パフォーマンスと可用性が向上する。

ただし、データの一貫性は考慮する必要があるし、上層サーバーをスケールアウトすれば、そのぶん、下部サーバーのスケールも上げる必要がある

##### ロードバランサの弱点

特徴ゆえか、単一障害点になりやすいのが一番の弱点。
そのため、フェイルオーバーを施すのはほぼマスト。
しかし、フェイルオーバーを施すと構成が複雑になってしまう。

#### トレードオフ例：リバースプロキシ

Webサーバーとインターネットの間を取り持つサーバー。
インターネットからのリクエストを受け取り、それに相応するサーバーに私、そのレスポンスを変わりにインターネットに流す。

プロキシーサーバーは、クライアントとインターネットの間を取り持つサーバーとして機能している。リバースプロキシはその反対側の立ち位置のため、そのように呼ばれている。

##### リバースプロキシの特徴

ロードバランサーと競合しそうに見えるが、Webサーバーが1台でも以下の恩恵があるのが大きな特徴。

* SSLによるリクエストの復号・レスポンスの暗号化
  * SSL termination
  * X.509証明書を各サーバーにインストールする必要がなくなる
* サーバーレスポンスの圧縮
* リクエストをキャッシングしてレスポンスを返す
* 静的データ（HTML・CSS・Image）を直接送信
* セキュリティ強化（バックエンドサーバーのブラックボックス化、IPブラックボックス、ソースIPの制限、接続数の制限）
  * ファイアーウォールのような事もできる
* 速度調整
  * Webサーバーに大きなデータ作成をリクエストすると、データが出来上がっても、クライアントがデータを取得しようとしない限りWebサーバーは処理を負えられない（プロセスを減らせないし、ポートを塞いでしまう）。
  * リバースプロキシが変わりに出来上がったデータをダウンロードしてキャッシュすることで問題を解消でき、クライアントもリクエストしたいときにできるようになる。

製品によってはロードバランサーに上記機能が実装されているものがあるため、境目があやふやになっている印象がある。

NGINXにはリバースプロキシとしても使える設定がある。

##### リバースプロキシの弱点

ロードバランサーと同じく、単一障害点になりやすいのでフェイルオーバーを施すことも視野に入れる。それ故に管理が複雑になることは否めない。

##### リバースプロキシが効果を示す場合

使用しているWebサーバーが単体の時はリバースプロキシが有効。
Webサーバーが複数台あるときはロードバランサーが役に立つ。

## アプリケーション層の分離

Webシステムを設計する際、アプリケーション層(プラットフォーム層)とその他の層を分離して設計すると、スケーリングする際や新しいAPIをデプロイする時にアプリサーバーだけ独立して対応できる。
不必要にWebサーバーをスケールしなくても良くなる。

これを実現しようとすると、マイクロサービスのような単一責任でサービス間の依存性が疎のシステム、マイクロ設計一択になる（アーキテクチャ・運用管理・プロセスの面から）。

アプリケーション層では非同期処理もサポートする

### モノリシック設計

モノリシック設計は小さいサービスを設計するには非常に有効（サーバーの構成やデプロイ・管理は楽、UIを統一できる）。
後にユーザーが増えたりサービスの多機能化・多様化が顕著になると他サービスとの依存関係確認が必要だったり、ちょっとしたデプロイでもシステムを全部デプロイする必要がある。マイクロ設計に移行する際もサービス間の通信などの複雑な構成を検討することになる。

### マイクロ設計

マイクロ設計は多機能もしくは大規模なサービスを構築する際にうってつけのアプローチ。小さなサービスが軽い通信を使って疎結合されていることから、サービスの追加やアップデートやスケーリングする際に手間がかからなくなる。
しかし、サービスが多くなったりスケーリングするためのデプロイや運用に手間がかかったり、物理サーバーやクラウドインスタンスが増えることによるコスト面の管理にも注力が必要。また、サービスごとに担当するグループやチームが違ったりすると、データアクセスやUIイメージ統一のための共有プロセスが多くなる。

### サービスディスカバリー

各サービスがどこにあってどこと連携すればよいのかを見つけやすくするための仕組み。サービスディスカバリーシステムではトランスポート層の情報やサービスの名前などが登録されており、これらを監視している。
監視や安全性チェックにはHTTPを使用したヘルスチェックを使用している。
ConsulやEtcdでは、独自のKey-Valueを活用して、共通の設定やデータを管理している。

### アプリケーション層分離の欠点

アーキテクチャ・運用・プロセスの面で、モノリシック設計での構築とは違ったアプローチが必要。
（初学者にはその点の先入観や固定観念が無いのでキャッチアップし易い？）
また、単純にサーバーが増えるため、デプロイが複雑になる

## データベース

データを管理・アクセスするためのシステム。分類で言えばミドルウェアに属する。
データベースは、メジャーなものとして以下の２点に分類される。

* [RDBMS(リレーショナルデータベースマネージメントシステム)](#データベースrdbms)
* [NoSQL](#データベースnosql)

また、以下ではRDBMSを選ぶかNoSQLを選ぶかの指標を列挙しているので参考にする。

* [RDBMSかNoSQLか](#rdbmsかnosqlか)

他にも、上記サイトには無いが、当方で追加した項目もいくつか上げる。

* [DB補足：NewSQL](#db補足newsql)
* [DB補足：準構造化データ](#db補足準構造化データ)
* [DB補足：データウェアハウス](#db補足データウェアハウス)
* [DB補足：データレイク](#db補足データレイク)
* [DB補足：データベースで気になる点](#db補足データベースで気になる点)

### データベース：RDBMS

データの集合を、テーブルとして整理・管理するシステム
テーブルへは、SQLを発行することでアクセスできる。
複数のSQL発行を一つの処理として認識することを「トランザクション」というプロセスが利用可能。問題なければ「Commit」、問題があれば「Rollback」することでデータベースの不可分性を担保する。

「不可分性」を含むトランザクションの必要分子を「ACID」と呼ぶが、既出のためここでの説明は省略。

データベースの冗長性を担保する技術がたくさんある。一例として以下のものがある。

* [マスター・スレーブレプリケーション](#db冗長性マスタースレーブレプリケーション)
* [マスター・マスターレプリケーション](#db冗長性マスターマスターレプリケーション)
* [federation](#db冗長性federation)
* [シャーディング](#db冗長性シャーディング)
* [非正規化](#db冗長性非正規化)
* [SQLチューニング](#db冗長性sqlチューニング)

#### DB冗長性：マスター・スレーブレプリケーション

役割として１台の「マスター」と複数台の「スレーブ」に分かれ、マスターが読み書きを担当、スレーブは読み取り専用として機能する。
マスターが書き込んだデータは、スレーブに複製する。
スレーブは木構造のようにデータの複製ができる。
マスターがオフラインになったときは、どれかのスレーブがマスターに昇格するか、マスターが復活するまで読み取り専用とする。

##### マスター・スレーブレプリケーションの欠点

* マスター昇格の実装をアプリ側で行う必要がある

#### DB冗長性：マスター・マスターレプリケーション

##### マスター・マスターレプリケーション共通の欠点

* どのマスターに書き込むかの前提を作る必要がある。要はロードバランサーを用意する必要がある
* 一貫性がゆるい。トランザクションの扱いに注意。
* 各マスターへの書き込みが増えるためにレイテンシが発生する可能性がる
* レイテンシが発生するすると書き込みの衝突が発生する（最悪デッドロック）

##### マスター・スレーブとマスター・マスター共通の欠点

* マスターがダウンすると、複製前のデータが消える可能性がある（ログが残っていれば復旧するが…）
* 読み込みレプリカを採用している場合、書き込み処理が肥大化すると書き込み処理で複製ノードが詰まり、レプリカからの読み込みに影響が出る可能性がある
* 読み取りスレーブ(読み込みレプリカ)の数が増えるとマスターからの書き込み量が増える
* マスターへの書き込みはマルチスレッドで並列に書き込めるシステムでも、スレーブへの複製では単一スレッドで書き込むようにしないと不都合の可能性がある
  * どのような不都合？
* 単純に、マスタースレーブやマスターマスター、読み込みレプリカを採用すると用意するサーバーが増え、複雑化する（サーバー構成の複雑化）

#### DB冗長性：federation

フェデレーション（機能分割化）は、モノリシックに単一のDBを用意するのではなく、機能ごとにDBを振り分けて負担を分散させる方式
例えば、Product、User、Forumのように分けておく。

##### federationの利点

* DB処理の負担分散
* DBやテーブルが小さくなるため、レプリケーションが軽くなる
* リクエストがパターン化されることからキャッシュのヒット率が上がる
* 並列処理が可能になり、スループットが上がる

##### federationの欠点

* 大規模な処理やテーブルを要するスキーマが必要なシステムのときは不向き
* アプリケーションロジックの実装時にその点を考慮する必要がある（コネクション作成などに注意を要する）
* 切り分けたDBを連結する処理が複雑になる
* サーバー構成の複雑化

#### DB冗長性：シャーディング

フェデレーションのように複数DBを用意するが、機能ごとではなく、データの構造（例：A-D,E-H,I-...）で分割して保持しておく（各DBでは断片化されたデータが書き込まれる）。
このように振り分けられたDB単体を「シャード」と呼ぶ

##### シャーディングの利点

（いくつかはfederationの利点と被っている）

* DB処理の負担が分散される
* シャード単位でのレプリケーションが軽くなる
* シャード単位でのキャッシュヒット率が上がる
* 並列処理が可能になり、スループットが上がる
* シャード単位でのインデックスの作成量が少なくなる
* 一つシャードが落ちたとしても、他のシャードへのアクセスには影響がない

##### シャーディングの欠点

* 各シャードへアクセスするためのアプリケーションロジックが必要
* 各シャードに振り分けたデータの割合が歪になる可能性があり、そうなると負担が大きいサーバができる危険性もある
* 切り分けたシャード間のデータを連結する処理が複雑になる
* サーバー構成の複雑化

#### DB冗長性：非正規化

正規化して結合だらけになるよりかは非正規でもいいから読み込みのレイテンシを減らそうという考え

* materialized viewsという機能で一貫性を持たせる
  * あとで調べる

##### 非正規化の利点

* 結合処理のコストを抑える

##### 非正規化の欠点

* データが重複して書き込まれる
* 過大な書き込みが必要となり、正規化されたものよりも高負担になることがある

#### DB冗長性：SQLチューニング

SQLチューニングに関しては、たくさんの本が出ているので参考に

##### SQLチューニングで大切なこと

ボトルネックを見つけて測定すること。そのためのベンチマークを定めてプロファイルすることが大事

* ベンチマーク: abなどをつかて高負荷のベンチマークを取ってみる
* プロファイル: slow query logなどを使ってパフォーマンス状況を確認する

ベンチマークとプロファイルを取ることで、以下の効率的な選択肢を取ることになる

##### スキーマを絞る

* MySQLでは、アクセス向上のためにデータをディスクに連続して格納している。
* 長さの決まったフィールドに対してはVARCHARよりCHARを使う
  * CHARをのほうが高速・ランダムにアクセスできる
  * VARCHARでは次のデータに移る前にデータの末尾を検知することにより効率的ではない
* 大きいテキストデータではTEXT型を使用する
* 2^32や40億以下しか扱わないときはINT型を使う
* 通貨に関してはDECIMALを使う(小数点表示上のバグを起こさない)
* 大きなBLOBSを保存するのを避ける
  * どこからそのデータを引き出せるかの情報を保存しておく
* VARCHAR(255)は8ビットで数えられる最後の文字数
  * RDBMSでは1倍との効率を最大にするためにVARCHARを積極的に使用する
* 検索性向上のため、なるべくNOT NULL制約を設定知る

##### インデックスを効果的に用いる

* クエリ(SELECT,GROUP BY,ORDER BY,JOIN)の対象としてインデックスを用いると性能向上の可能性がある
* インデックスは通常**B木**で表される。B木はデータがソートされた状態になる。
  * 検索、順次アクセス、挿入、削除が対数時間で行える
* インデックスを配置する=データを残す=ディスクを使う
* データを更新する=インデックスを更新する=時間がかかる
* 大量のデータをロードする際はインデックスを一旦切ってデータをロード、再びインデックスを構築したほうが早い時がある

##### 高負荷なJOINは避ける

* どうしてもそういうデータが必要なときは非正規化を使う

##### テーブルのパーティション

ホットスポットが独立したテーブルになるようにテーブルを分割して、クエリ結果がメモリに乗せられるように施す。

##### クエリキャッシュを調整する

場合によってはクエリキャッシュによるパフォーマンス問題が引き起こされる。

* パフォーマンスに問題がありそうだったら、クエリキャッシュを無効にして、インデックスを作成したり、レプリカを用意したり、外部キャッシュ(MemcachedやRedis)を導入したりする。

##### SQLチューニングの参考リンク

* [MySQLクエリを最適化するためのTips](http://20bits.com/article/10-tips-for-optimizing-mysql-queries-that-dont-suck)
* [VARCHAR(255)をやたらよく見かけるのはなんで？](https://stackoverflow.com/questions/1217466/is-there-a-good-reason-i-see-varchar255-used-so-often-as-opposed-to-another-l)
* [null値はどのようにパフォーマンスに影響するのか？](https://stackoverflow.com/questions/1017239/how-do-null-values-affect-performance-in-a-database-search)
* [Slow query log](https://dev.mysql.com/doc/refman/5.7/en/slow-query-log.html)

### データベース：NoSQL

データを「アイテム」の集合として管理するシステム。

NoSQLの構成として以下の4つがある。

* [key-value store](#nosqlkey-value-store)
* [document-store](#nosqldocument-store)
* [wide column store](#nosqlwide-column-store)
* [graph database](#nosqlgraph-database)

#### NoSQLの特徴

* 基本的に正規化されない
* JOINはアプリケーション側で行う
* 大部分のNoSQL DBは真のACIDトランザクションを持たない
* 結果整合性な振る舞いを好む

#### NoSQLの参考リンク

* [基本用語の説明](http://stackoverflow.com/questions/3342497/explanation-of-base-terminology)
* [NoSQLデータベースについて調査と選択ガイド](https://medium.com/baqend-blog/nosql-databases-a-survey-and-decision-guidance-ea7823a822d#.wskogqenq)
* [誰でもわかるスケーラビリティ - パート 2: データベース](https://www.lecloud.net/post/7994751381/scalability-for-dummies-part-2-database)
* [(Youtube)NoSQLのイントロダクション](https://www.youtube.com/watch?v=qI_g07C_Q5I)
* [NoSQLパターン](http://horicky.blogspot.com/2009/11/nosql-patterns.html)

#### BASE理論

NoSQLのプロパティを説明する際に用いられるのがBASE理論。
既出のため詳細は省略

* Basically Available
  * 楽観ロックやキューで基本的な可用性を持たせる
* Soft state
  * システムが持つデータは時間とともに変更される(一貫性がない)
* Eventually Consistent
  * 更新してすぐには結果が反映さないこともあるが、最終的にはデータの一貫性が保たれる

#### NoSQL：key-value store

ハッシュテーブルのように、キーと値が一対一で保存されている。
キーが辞書順に保存されていることに寄って効率的な検索が可能。
一般的にO(1)の読み書きができることが前提。
メタデータ値とともに保存することが可能。

ただし、単純な出し入れができる代わりに、それが制限となってしまうため、複雑なデータを取り出したい場合はアプリケーション層に追加してそれに委ねられる。

key-value storeは、他の3種の基本となる要素。

製品の例として、Tokyo Cabinet(Tokyo Tyrant)、AWS DynamoDBがある。
memcachedやredisも一応仲間として考えられる。

#### NoSQL：document-store

キーと対になる値として、「ドキュメント(JSONやXML、バイナリデータなど)」という、オブジェクトに関する全ての情報を持つデータを保存しているシステム。メタデータを保存できるkey-value storeとの境界があやふやになっている。
フィールドの構成は統一されていない。
document-storeを実現するために、コレクション、タグ、メタデータやディレクトリなどとして整理している。
データを検索する際に検索キーを「.../.../...」として渡しているのは上記のコレクションやタグを指定している。

製品の例として、CouchDBやMongoDBがある。AWS DynamoDBはdocument-storeもサポートしている。

高い柔軟性を持っているため、頻繁にデータが変化するときに用いられる。

* [Wikipediaでの説明(日本語版は無し)](https://en.wikipedia.org/wiki/Document-oriented_database)
* [MongoDB アーキテクチャ](https://www.mongodb.com/mongodb-architecture)
* [CouchDB アーキテクチャ](https://blog.couchdb.org/2016/08/01/couchdb-2-0-architecture/)
* [Elasticsearch アーキテクチャ](https://www.elastic.co/blog/found-elasticsearch-from-the-bottom-up)

#### NoSQL：wide column store

key-value storeに「行志向」を持たせたシステム。

データベースの構成は「行」として構成されている。各行は「行キー」が割り振られて、それを指定することでデータを取り出したり保存ができる。

データの基本単位は「カラム(Name-Valueのペア)」で、各カラムの集合を「カラムファミリー」としてグループ化できる。更に、カラムファミリーを「スーパーカラムファミリー」としてグループできる。1行内のカラム構成は自由。

「カラムファミリー」も「スーパーカラムファミリー」も一つの「カラム」として認識できる。つまり、カラムをネスト構造で管理できる。

それぞれの値はコンフリクトを避けるためにタイムスタンプも同時に保存されている。

製品の例として、GCP BigTable、Hadoopで使われているHBase、Facebook Cassandraがある。

* [データベースのデータレイアウトについて](https://blog.foresta.me/posts/database-data-layout/)
* [IoT時代のデータストア--躍進するNoSQL、拡張するRDB](https://japan.zdnet.com/article/35097286/)

#### NoSQL：graph database

RDBMSで言うレコードがグラフのノードとして存在し、ノード間を「アーク(弧、矢印付き)」で結んで関連性を付けている。
多数の外部キーや多対多の関係を構築するのに向いている。

SNSのデータなど、複雑な関係性を持つ情報を管理するのに役立っているが、まだ新しいシステムのためか、一般的にはまだ使われていない。それ故か、開発ツールやリソースを探すのに苦労する。

製品としてはNeo4j、FlockDBがある。

多くのgraph databaseではREST APIを通じてアクセスする。

* [Wikipediaでの説明(日本語版は無し)](https://en.wikipedia.org/wiki/Graph_database)
* [Neo4j](https://neo4j.com/)
* [FlockDB](https://blog.twitter.com/engineering/en_us/a/2010/introducing-flockdb)

### RDBMSかNoSQLか

(綺麗にまとまっているので転載)

#### SQL を選ぶ理由

* 構造化されたデータ
* 厳格なスキーマ
* リレーショナルデータ
* 複雑なジョインをする必要性
* トランザクション
* スケールする際のパターンが明確なとき
* 開発者の数、コミュニティ、コード等がより充実している
* インデックスによるデータ探索はとても速い

#### NoSQL を選ぶ理由

* 準構造化されたデータ
* ダイナミックないし、フレキシブルなスキーマ
* ノンリレーショナルなデータ
* 複雑なジョインをする必要がない
* データの多くのTB (もしくは PB) を保存する
* 集中的、大規模なデータ負荷に耐えられる
* IOPSについては極めて高いスループットを示す

#### NoSQLに適するサンプルデータ

* 急激なクリックストリームやログデータの収集
* リーダーボードやスコアリングデータ
* ショッピングカートなどの一時的情報
* 頻繁にアクセスされる (ホットな) テーブル
* メタデータやルックアップテーブル

#### RDBMS vs NoSQLを知るための参考資料

* [(Youtube)最初の1000万ユーザーにスケールアップするために](https://www.youtube.com/watch?v=w95murBkYmU)
* [SQLとNoSQLの違い](https://www.sitepoint.com/sql-vs-nosql-differences/)

### DB補足：NewSQL

ACID特性をもたせたNoSQLとしてNewSQLが考案され、いくつかの製品が登場しているが、詳しい説明は割愛

* [データベース事始め](https://qiita.com/AkitsuguHirano/items/980de403cc7fe6c941e3)

### DB補足：準構造化データ

RDBMSテーブルの行・列のように完全に構造化されたものではなく、タグなどである程度規則化されているが完全ではないデータのこと。JSONやYAML、HTMLタグ、XMLタグ、ラベルなどのマークアップが埋め込まれたデータが挙げられる。

半構造化データとも呼ばれている。

* [半構造化データとはなにか？](https://jp.drinet.co.jp/blog/datamanagement/semi-structured-data)
* [半構造化データの概要](https://docs.snowflake.com/ja/user-guide/semistructured-intro.html)

### DB補足：データウェアハウス

利用者によって変わってくるが、時系列に整理された大量の業務用データ、それを管理するシステム。データベースとの大きな違いは、分析に特化したデータ集合体となっている。

データウェアハウスとしては[databricks社](https://www.databricks.com/jp/)が知られている。

* [Wikipediaの記事](https://ja.wikipedia.org/wiki/%E3%83%87%E3%83%BC%E3%82%BF%E3%82%A6%E3%82%A7%E3%82%A2%E3%83%8F%E3%82%A6%E3%82%B9)
* [データウェアハウスについて](https://it-trend.jp/dwh/article/149-0001)

### DB補足：データレイク

規模に関係なく、画像・動画・メール・ログなどの非構造化データを生データのまま格納できる。

データレイクとデータウェアハウスのいいとこ取りに加えてACIDトランザクションを採用したオープンアーキテクチャがデータレイクハウス。

* [データレイクを始めとした説明](https://www.databricks.com/jp/blog/2020/01/30/what-is-a-data-lakehouse.html)
* [Oracleのデータレイクハウス](https://www.oracle.com/jp/data-lakehouse/)

### DB補足：「データベース」で気になる点

* レプリケーション共通の弱点で、「書き込みは読み取りレプリカにおいてリプレイされる」と書かれているが、どのようなシチュエーションで書かれているのか理解できなかった。
  * リプレイテスト(本番の書き込みを再現して負荷テストとして使用する)と混同してしまう
  * 読み取りレプリカ(負荷分散のための、読み込み専用DBのこと。読み込みリクエストをレプリカへ分散させられる)へのリプレイとは？
  * マスターDBからの書き込みをレプリカDBへ反映させる、つまり一つのDBが2回書き込み処理を行うからリプレイ？

## キャッシュ

リクエストの結果を一時的に保管しておき、同じリクエストが来たら保管しておいたデータを返すシステム。

ページの読み込み時間を短くしたり、サーバーやデータベースの負担を和らげる（トラフィックをの急激な増加を吸収する）効果がある。

キャッシュ特有の動きとして、データの検索方法がディスク前提（シーケンスにデータを読み込む）ではなく、メモリ内前提の内容に最適化される（検索木を作る）ため、遥かに高速に動かせる。

単体の製品としてはmemcachedやRedisが有名。

キャッシュを使うかどうかは、キャッシュと各サーバーの間にディスパッチャを挟み、そこで判別する方式を取る。
RailsなどのWebフレームワークではRedisなどのキャッシュサーバーを指定できるようになっている。

どこでキャッシングするかについてはいくつかの場合があるので、以下の項目を参照して欲しい。

* [クライアントキャッシング](#キャッシュクライアントキャッシング)
* [CDNキャッシング](#キャッシュcdnキャッシング)
* [Webサーバーキャッシング](#キャッシュwebサーバーキャッシング)
* [データベースキャッシング](#キャッシュデータベースキャッシング)
* [アプリケーションキャッシング](#キャッシュアプリケーションキャッシング)

**（キャッシュレベルとはなにか不明のため、あとで調べる）**
キャッシュのレベルとして、以下の2つが存在する。

* [データベースクエリレベルでのキャッシング](#キャッシュレベルデータベースクエリレベルでのキャッシング)
* [オブジェクトレベルでのキャッシング](#キャッシュレベルオブジェクトレベルでのキャッシング)

また、キャッシュの対象や更新タイミングを以下の項目でまとめている。

* [何をキャッシュするのか](#何をキャッシュするのか)
* [いつキャッシュを更新するのか](#いつキャッシュを更新するのか)

キャッシュを利用することによる欠点は以下のものがある。

* cache invalidationなどを用いて、データベースなどの真のデータとキャッシュの間の一貫性を保つ必要があります。
* Redisやmemcachedを追加することでアプリケーション構成を変更する必要があります。
* Cache invalidationも難しいですがそれに加えて、いつキャッシュを更新するかという複雑な問題にも悩まされることになります。

キャッシュについて参考になるページはこちら

* [From cache to in-memory data grid](http://www.slideshare.net/tmatyashovsky/from-cache-to-in-memory-data-grid-introduction-to-hazelcast)
* [スケーラブルなシステムデザインパターン](http://horicky.blogspot.com/2010/10/scalable-system-design-patterns.html)
* [スケールできるシステムを設計するためのイントロダクション](https://lethain.com/introduction-to-architecting-systems-for-scale/)
* [スケーラビリティ、可用性、安定性、パターン](https://www.slideshare.net/jboner/scalability-availability-stability-patterns/)
* [スケーラビリティ](https://www.lecloud.net/post/9246290032/scalability-for-dummies-part-3-cache)
* [AWS ElastiCacheのストラテジー](https://docs.aws.amazon.com/AmazonElastiCache/latest/red-ug/WhatIs.html)
* [Wikipediaの記事](https://ja.wikipedia.org/wiki/%E3%82%AD%E3%83%A3%E3%83%83%E3%82%B7%E3%83%A5_(%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0))

### キャッシュ：クライアントキャッシング

OSやWebブラウザなどのクライアントサイド、サーバーサイド、もしくは独立したレイヤーに用意されている。

### キャッシュ：CDNキャッシング

CDNも一種のキャッシュとして考えられる。

### キャッシュ：Webサーバーキャッシング

リバースプロキシがその一例。Webサーバー単体でもページキャッシュ機能を持っていて、アプリケーションサーバーにアクセスすることなく結果を返せる。

### キャッシュ：データベースキャッシング

データベースにも一般的にキャッシュ機能を持っている。システムの特性に合わせて設定を変えるとパフォーマンスが向上できる。

### キャッシュ：アプリケーションキャッシング

memcached、Redisなどのこと。メインメモリ内でkey-valueストアを持っている。メインメモリは容量に制限があるため、ホット（直近に結果を返した）なデータを取り扱う。

### キャッシュレベル：データベースクエリレベルでのキャッシング

データベースクエリのハッシュをキーとして結果を保存する形式。
同じクエリが来たときは良いが、複雑なクエリがキャッシュされたときいそれを削除できない弊害があったり、テーブルの内容が更新されたときはキャッシュを全削除する必要があるリスクがある。

### キャッシュレベル：オブジェクトレベルでのキャッシング

データベースからのデータをオブジェクトとして組み立て直し、それらをキャッシュする。キーの形式はアプリケーションレベルで決める。
また、ワーカーが作成した最新のオブジェクトを取り込むことで非同期によるキャッシングを実現可能。
データが変更されたら、キャッシュしたデータはすべて削除する必要がある。

### 何をキャッシュするのか

* ユーザーのセッション
* 完全にレンダーされたウェブページ
* アクテビティストリーム
* ユーザーグラフデータ

### いつキャッシュを更新するのか

キャッシュを更新するタイミングはアプリケーションの内容に依存する。そのための検討は必要だが、更新に関しては以下の4つの方法が主に使われている（ほかは知らない）。

* [キャッシュアサイド](#キャッシュ更新キャッシュアサイド)
* [リードスルー](#キャッシュ更新リードスルー)
* [ライトスルー](#キャッシュ更新ライトスルー)
* [ライトビハインド (ライトバック)](#キャッシュ更新ライトビハインド-ライトバック)
* [リフレッシュアヘッド](#キャッシュ更新リフレッシュアヘッド)

#### キャッシュ更新：キャッシュアサイド

アプリケーションがキャッシュとデータベースを管理し（キャッシュはストレージと直接やり取りしない）、キャッシュにないデータはアプリケーションがデータベースから取得してキャッシュに組み込む方式。

Memcachedの通常操作。

キャッシュされれば非常に早いがキャッシュミスした際は３つのトリップを行うことになるので目に見える遅延がある。
データベースの値が更新されるとキャッシュされたデータが古くなるため、time-to-live(TTL)、更新後キャッシュ削除、ライトスルーを採用すれば緩和される。
ノードが落ちると、新規の空のノードで代用されるためレイテンシーが増加する。

#### キャッシュ更新：リードスルー

キャッシュアサイドではアプリケーションが担うキャッシュ管理を専用のローダーが担う方式。
キャッシュアサイドと同じリスクがある。

#### キャッシュ更新：ライトスルー

ユーザーは読み込み時よりも書き込み時のほうがレイテンシ増加に許容敵なことを利用する。
アプリケーションはキャッシュをメインのデータストアとして使用する。キャッシュがデータベースへの更新を担う。

キャッシュも更新処理を行うため全体的なレイテンシは増加するが、データの一貫性（最新）を保てる。

ノードが落ちたり、スケーリングしたりすることで新しいノードが作成された状態ではキャッシュが空になってしまい、次の更新が来るまでキャッシングされない。そこはキャッシュアサイドとライトスルーを併用することで緩和できる（ライトスルーでヒットしなければキャッシュアサイドを使用、更新時にキャッシュアサイドも更新）。
書き込まれたデータの大部分は一度も読み込まれない（つまり、キャッシュからの書き込みが無駄になる）。書き込み速度を早めるためにTTLによる圧縮を施す。

#### キャッシュ更新：ライトビハインド (ライトバック)

アプリケーションがキャッシュに書き込んだ後、一定時間何も更新されなかったらそのキャッシュをイベントとしてキューに送り、イベントハンドラが非同期的にDBを操作する。非同期にすることで書き込み時のパフォーマンスが上がることが期待できる。

イベントハンドラに送る前にキャッシュが落ちると最新のデータが消えてしまうリスクがある。
非同期処理もあるため、この方式でのキャッシュを実装しようとするとキャッシュアサイドやライトスルーよりも複雑になってしまう。

#### キャッシュ更新：リフレッシュアヘッド

キャッシュの期限切れよりも前に、キャッシュがすべてのエントリを更新するように設定する。
更に、更新するキャッシュが予測できるようになれば更にパフォーマンスが上がる。

つまり、予測が当てにならなければ（できなければ）、レイテンシは期待できないということになる。

## 非同期処理

プロセスの中で非常に重い処理(スループットに影響が出る)を別の処理に任せてリクエスト時間を抑える方法。
また、定期的に必要な思い処理を別で実行させて事前準備させられる理転がある。

非同期処理を構成するものとして、以下のキューを使用する。

* [メッセージキュー](#非同期処理の構成メッセージキュー)
* [タスクキュー](#非同期処理の構成タスクキュー)

また、キューが無尽蔵に大きくなることを防ぐために以下のものを採用すると制限をかけられる。

* [バックプレッシャー](#バックプレッシャー)
  * [指数バックオフ](#バックプレッシャー指数バックオフ)

### 非同期処理の構成：メッセージキュー

フロント側ではジョブをメッセージとしてキューに投げ、キューではメッセージを取得・保存・配信に対応、ワーカー側で対応するメッセージが投げ込まれたら、対応するジョブを処理してキューに返す方式。

ジョブがユーザの目に余るほど処理時間がかかりそうなときは、フロント側はジョブステータス（例えば、「処理中」のメッセージをブラウザに返すなど）をユーザ側に返し、ワーカー側はジョブを処理して、完了したら完了のシグナルを返す。結果があればその後返す。

クライアント側では、ジョブステータスが来たらタスクが完了したように見せるオプションもある。

メッセージキューを実装している製品はいくつがあるが、それぞれ弱点もある。

#### Redisによるメッセージキュー

シンプルなメッセージなら対応使える。
しかし、シンプル故にメッセージが失われる可能性がある。

#### RabbitMQによるメッセージキュー

メッセージキューとしてメジャー。
AMQPプロトコルに対応した処理を実装する必要がある。

#### Amazon SQSによるメッセージキュー

レイテンシーが高く、メッセージの重複もある。

### 非同期処理の構成：タスクキュー

タスクと必要なデータをキューに投げる方式。
タスク単位のため、タスクのスケジューリングが可能。
非常に思い処理をバックグラウンドで実行できる。

### バックプレッシャー

キューに大多数のメッセージが送られると、メモリよりもキューが大きくなってしまい、キャッシュのヒットミスが頻発したり、ディスク読み出しによるパフォーマンス低下のリスクがある。

そこで、キューが一杯になるとServer Busyもしくは503エラーを返すことで、クライアント側に時間を置いて(間隔は[指数バックオフ](#バックプレッシャー指数バックオフ)がふさわしい)の再リクエストを促すことでキューを制限することでパフォーマンスを保つことができる。この対応をバックプレッシャーと呼ぶ。

* [Applying Back Pressure When Overloaded](https://mechanical-sympathy.blogspot.com/2012/05/apply-back-pressure-when-overloaded.html)
* [バックプレッシャーについて](https://learn.microsoft.com/ja-jp/exchange/mail-flow/back-pressure?view=exchserver-2019)

### バックプレッシャー：指数バックオフ

クライアント側が再リクエストをするときの間隔を一定間隔ではなく指数的に間隔を広げてリクエストをすると適切な間隔になるというアプローチのこと。これにより、リクエストを頻発しなくなるため、サーバーへの負担を防ぐ一助になる。

* [リトライ処理の効率的アプローチ「Exponential Backoff」の概要とGoによる実装](https://qiita.com/po3rin/items/c80dea298f16a2625dbe)

## 通信

通信に関して必要な最低限の情報をまとめている。
まとめている情報は以下のもの。
OSI参照モデルについては当方でまとめ直した。

* [OSI参照モデル](#通信osi参照モデル)
* [Hypertext transfer protocol (HTTP)](#通信http)
* [伝送制御プロトコル (TCP)](#通信tcp)
* [ユーザデータグラムプロトコル(UDP)](#通信udp)
* [遠隔手続き呼び出し(RPC)](#通信rpc)
* [Representational state transfer(REST)](#通信rest)

### 通信：OSI参照モデル

通信に関して覚えておくものはやはりOSI参照モデル。
ネットワークのプロトコルを役割で分類し、明確化するためのモデル。
参照モデルでは、以下の７層（レイヤー）構造で構成されている。
大抵の書籍では第７層から順番に解説しているが本ドキュメントでは第１層から順番に解説する。

* [第1層：物理層](#物理層)
* [第2層：データリンク層](#データリンク層)
* [第3層：ネットワーク層](#ネットワーク層)
* [第4層：トランスポート層](#トランスポート層)
* [第5層：セッション層](#セッション層)
* [第6層：プレゼンテーション層](#プレゼンテーション層)
* [第7層：アプリケーション層](#アプリケーション層)

#### 物理層

* データリンク層からのサービス欲求に応える。
* ネットワークを繋ぐための物理的な手段を定義。
* デバイス例：LANハブ、光回線ケーブル、RS-232C、10Base-T、100Base-T、1000Base-TX

#### データリンク層

* ネットワーク層からのサービスに応答し、物理層にサービスを要求する。
* 物理層で発生するエラー検出方法やそのエラーや誤りを訂正する方法を提供する。
* デバイス例：スイッチングハブ、ソフトウェアネットワークドライバ
* プロトコル例：PPP、IEEE802.11(無線LAN)、イーサネット、トークンリング

#### ネットワーク層

* トランスポート層からのサービスに応答し、データリンク層にサービスを要求する。
* パケットの起点から終点まで問題なことを担保するため、パケットの経路選択（ルーティング）や中継を行う。
* 皆さんご存知のIPアドレスもこのネットワーク層で使われる。
* デバイス例：ルータ
* プロトコル例：IP、IPv4、IPv6、IPX、IPSec

#### トランスポート層

* セッション層からのサービスに応答し、ネットワーク層にサービスを要求する。
* ネットワーク層によって提供された信頼性が低く基本的なサービスをより強力なものに変換する。
  * データのパケット化、データ・パケット・ヘッダへのポート番号の追加
  * TCPでは誤り検出や自動再送要求(ARQ)によるエラー復旧もサポートしている。
* 通常、ホストコンピュータ上のOSによって制御される
* プロトコル例：TCP、UDP

#### セッション層

* プレゼンテーション層からのサービスに応答し、トランスポート層にサービスを要求する。
* アプリケーション・プロセス間のセッションの開始・終了・再開（中断した接続の回復など）・管理の機構を提供することで半永久的な対話を実現する。
* 協調するアプリケーション間でセッションを確率・管理・終了する。
* 通常、ホストコンピュータ上のOSによって制御される
* プロトコル例：RPC、NetBIOS、SIP、ZIP、H.245、SQL

#### プレゼンテーション層

* アプリケーション層からのサービスに応答し、セッション層にサービスを要求する。
* 情報の配布と書式に関する責任を負う。
* 情報の符号化や変換を行う。
* プロトコル例：ASCII、UTF-8、JPEG、PNG、GIF

#### アプリケーション層

* ユーザが直接制御する層。プレゼンテーション層にサービスを提供する。
* アプリケーションがネットワークを介して通信をする際、内容にふさわしい手続きを提供している。
* プロトコル例：HTTP、HTTPS、SSH、POP3、FTP、DHCP

* [WikipediaでのOSI参照モデル](https://ja.wikipedia.org/wiki/OSI%E5%8F%82%E7%85%A7%E3%83%A2%E3%83%87%E3%83%AB)
* [初心者のためのネットワークモデル：OSI参照モデル](https://www.itbook.info/study/p39.html)
* [ネットワーク技術者のための基礎理論](https://itskillmap.com/menu5_12/)

### 通信：HTTP

クライアントとサーバー間でデータをエンコードして転送するための手法。クライアント側がリクエストをサーバーに投げ、サーバーはレスポンスとしてクライアントに投げ返す手続き。
HTTPは自己完結するため、間にロードバランサやキャッシュなどの中間ルーターが入っても確実に通信できる。

TCPとUDPなどの下位層のプロトコルに依存している。

HTTPの手続きはメソッドとリソース（エンドポイント）によって構成されている。
主要なメソッドは以下。

冪等性：更新されていなければ何度リクエストしても必ず同じ結果が帰ってくること
セーフ：リクエストによって、サーバーの状態を変更しないこと

* [MDNのSafeに関する記事](https://developer.mozilla.org/ja/docs/Glossary/Safe/HTTP)

* [HTTPってなに？](https://www.nginx.com/resources/glossary/http/)
* [HTTPとTCPの違い](https://www.quora.com/What-is-the-difference-between-HTTP-protocol-and-TCP-protocol)
* [PUTとPATCHの違い](https://laracasts.com/discuss/channels/general-discussion/whats-the-differences-between-put-and-patch?page=1)

#### GET

リソースを読み取る動詞。

* 冪等性あり
* セーフを担保
* キャッシュ可能

#### POST

リソースを作成・データ処理する動詞。

* 冪等性なし
* レスポンスが新しい情報を持つ場合、キャッシュ可能

#### PUT

リソースを作成・入れ替える動詞。

* 冪等性あり
* キャッシュ不可

#### DELETE

リソースを削除する動詞。

* 冪等性あり
* 当然ながらキャッシュ不可

#### PATCH

リソースを一部更新する動詞。

* 冪等性なし
* レスポンスが新しい情報を保つ場合、キャッシュ可能

### 通信：TCP

IP Networkで成り立つ接続プロトコル。トランスポート層を引き受けるプロトコル。
接続は「ハンドシェイク」によって接続を開始したり解除する。
すべてのパケットはすべて欠損なく送受信することを担保する。
担保の方法は以下のものがある。

* sequence numberとchecksum fieldがすべてのパケットに用意されている。
* Acknowledgeパケットによる自動再送信

送信時に正しいパケットを受け取らなかったときにはパケットを再送信する。
複数タイムアウトがあったときに接続が解除される。
TCPはフロー制御と輻輳制御を持っているがゆえに、UDPより速度低下による非効率な転送手段となる。

高い依存性を持ち、時間制約があまり厳しくないときに使える。
Webサーバー、データベース情報、SMTP、FTP、SSHなどの例に適応される。

#### フロー制御

２つのノードが、高速な送信側が低速な受信側の能力を超えてオーバーフローやオーバーランを防止するための管理プロセス。

[Wikipediaの説明](https://ja.wikipedia.org/wiki/%E3%83%95%E3%83%AD%E3%83%BC%E5%88%B6%E5%BE%A1)

#### 輻輳制御

ネットワークが複雑になって、パケットがたどるルートが大回りになってネットワークの許容量（処理能力やリンク数）を食いつぶさないように監視するための管理プロセス。

[Wikipediaでの説明](https://ja.wikipedia.org/wiki/%E8%BC%BB%E8%BC%B3%E5%88%B6%E5%BE%A1)

#### TCPを使うほうがよいとき

* 必ず正しいデータが送受信されることが要求されているとき
* ネットワークスループットの最適な自動推測をやりたい

### 通信：UDP

コネクションレスの通信（TCPのハンドシェイクのようなものはない）。データグラム（後述のWikipedia記事参照）はデータグラム単位での保証しかしない。また、データグラムは順不同で欠損も発生するのでそれを覚悟の上で送受信を実装する。
それゆえにTCPよりも効率的に動作する。

[Wikipediaでのデータグラムの説明](https://ja.wikipedia.org/wiki/%E3%83%87%E3%83%BC%E3%82%BF%E3%82%B0%E3%83%A9%E3%83%A0)

UDPはサブネット上のすべての機器にデータグラムを送受信できる。
DHCPでは、まだクライアントではIPアドレスを取得していないので、IPアドレスを必要とするTCPにストリームはできないため。

UDPはたしかに信頼性の面でTCPより劣るが、リアルタイム性が重視されるシステムにとってうってつけな転送手段。
例：オンラインゲーム、VoIP、ビデオチャット、ストリーミング

#### UDPを使う方がいい時

* レイテンシーを最小に抑えたい
* データ欠損よりもデータ遅延を重視するとき
* エラー修正を自前で実装したいとき

#### TCPとUDPに関するリンク集

* [UDP vs. TCP (Game Networking)](https://gafferongames.com/post/udp_vs_tcp/)
* [What is the difference between UDP and TCP internet protocols?](https://www.cyberciti.biz/faq/key-differences-between-tcp-and-udp-protocols/)
* [Difference between TCP and UDP?](http://stackoverflow.com/questions/5970383/difference-between-tcp-and-udp)
* [Wikipediaの記事(TCP)](https://ja.wikipedia.org/wiki/Transmission_Control_Protocol)
* [Wikipediaの記事(UDP)](https://ja.wikipedia.org/wiki/User_Datagram_Protocol)
* [Facebookで行われているMemcachedサーバーのスケーリング(PDF)](https://www.cs.bu.edu/~jappavoo/jappavoo.github.com/451/papers/memcache-fb.pdf)

### 通信：RPC

データを送るだけではなく、リモートサーバーでプログラムを実行させるための通信手段。HTTPなどを介して呼び出す処理の名前とパラメータを渡すことでサーバーサイドでプログラムが実行され、結果をクライアントに返す仕組み。

#### RPCの特徴

異なるマシン上でも、実行させるプログラムの書式を共通化（メソッド名や引数の書式など）させれば動作できる。

RPCの方がやはりローカル呼び出しのほうが速く信頼性があまり…なので、ローカルコールと区別して考える。また、セキュリティ面でも、呼び出すメソッド名が丸見えとなるリスクがある。

更に、RPCはメソッドの構造が1階層しかないため、複雑な構造のメソッド呼び出しができない（これはRESTの方に分がある）

RPCのフレームワークとして有名なのに Protobuf(Google)、Thrift(Apache)、Avro(Apache) がある。
また、GoogleによってRPCの弱点を補ったgRPCが作られている(RPCはテキストデータしか対応していないが、gRPCではバイナリデータをシリアライズすることで対応している)。

#### RPC実行の手順

RPCを実装する手続きとして、クライアント側では以下の手順でリクエスト／レスポンスを行う。

* クライアントプログラム
  * クライアントスタブプロシージャを呼び出す
  * パラメーターはローカルのプロシージャー呼び出しのようにスタックにプッシュする
* クライアントスタブプロシージャ
  * クライアント通信モジュールを呼び出す
  * プロシージャIDとパラメーターをパック(クエリパラメータ付きGETリクエストやDATA付きPOST呼び出しのリスト)して、リクエストのメッセージ本体として作成する
* クライアント通信モジュール
  * OSの通信機能を利用してサーバーに投げる
* サーバー通信モジュール
  * OSが受けったリクエストをサーバースタブプロシージャに渡す
* サーバースタブプロシージャ
  * 結果を復号し、プロシージャIDにマッチするサーバープロシージャを呼び出し、結果を返す
  * 結果をパックしてレスポンスのメッセージ本体として作成、サーバー通信モジュールに引き渡す

サーバー側では、上記5ステップを逆順に実行する。

#### RPCの使われ方

基本的に、RPCは内部通信プロセスとして実装する(逆に、RESTはパブリックなAPIを実装するときによく使用される)。
セキュリテイの問題の面もあるが、内部でネイティブコールを自作できるため。

例えば、ネイティブライブラリー (aka SDK) を呼び出すの検討するのは以下の時:

* ターゲットのプラットフォームを知っている時
* ロジックがどのようにアクセスされるのかを管理したいとき
* ライブラリー外でエラーがどのようにコントロールされるかを管理したい時
* パフォーマンスとエンドユーザーエクスペリエンスが最優先の時

#### RPCの弱点

* RPCクライアントとはサービス実装により厳密に左右されることになります。
* 新しいオペレーション、使用例があるたびに新しくAPIが定義されなければなりません。
* RPCをデバッグするのは難しい可能性があります。
* 既存のテクノロジーをそのまま使ってサービスを構築することはできないかもしれません(例えば、SquidなどのサーバーにRPCコールが正しくキャッシュ されるように追加で骨を折る必要があるかもしれません)。

#### 参考文献

* [RPCの基礎概念](http://www.coins.tsukuba.ac.jp/~yas/classes/dsys-2008/2008-12-25/index.html)
* [RPCとRESTの違いについて](https://tokidoki-web.com/2021/03/rest-apirpcweb/)
* [サービス間通信のための新技術「gRPC」入門](https://knowledge.sakura.ad.jp/24059/)
* [JSON-RPCって何？](https://qiita.com/oohira/items/35e6eaaf4b44613ad7d3)

### 通信：REST

（解説文が意味不明すぎて別ドキュメントで理解する必要がある）

クライアント・サーバー実装をHTTPを使って柔軟に設計するアーキテクチャ。URIをAPIメソッドの一種として捉え、クライアント側では、さも単なるHTTPリクエストとしてAPIを呼び出せる。また、HTTPメソッド、リクエストヘッダ、URIパス、クエリパラメータなど、既存の情報を利用して、サーバー側でさまざまな処理へ振り分けることができる。

すべての通信はステートレスでキャッシュできなければならない。

ステートレスであるがゆえに、サーバーのスケーリングがやりやすい。

#### RESTの特徴

* 特徴的なリソース (URI in HTTP) - どのオペレーションであっても同じURIを使う。
* HTTP動詞によって変わる (Verbs in HTTP) - 動詞、ヘッダー、ボディを使う
* 自己説明的なエラーメッセージ (status response in HTTP) - ステータスコードを使い、新しく作ったりしないこと。
* HATEOAS (HTML interface for HTTP) - 自分のwebサービスがブラウザで完全にアクセスできること。

#### RESTの弱点

(もとのドキュメントから転載)

* RESTはデータ公開に焦点を当てているので、リソースが自然に整理されていなかったり、シンプルなヒエラルキーで表せられない時にはよい選択肢とは言えないかもしれません。例えば、とあるイベントのセットにマッチするすべての更新情報を返すと言った処理は簡単にはパスで表現することができません。RESTでは、URIパス、クエリパラメータ、そして場合によってはリクエストボディなどによって実装されることが多いでしょう。
* RESTは少数の動詞に依存しています(GET、POST、PUT、DELETE、そして PATCH) が時には使いたい事例に合わないことがあります。例えば、期限の切れたドキュメントをアーカイブに移したい場合などはこれらの動詞の中には綺麗にはフィットしません。
* ネストされたヒエラルキーの中にあるリソースをとってくるのはシングルビューを描画するのにクライアントとサーバー間で数回やりとりしなければなりません。例として、ブログエントリーのコンテンツとそれに対するコメントを表示する場合などです。様々なネットワーク環境で動作する可能性が考えられるモバイルアプリケーションにおいてはこのような複数のやり取りは好ましくありません。
* 時が経つにつれて、APIレスポンスにより多くのフィールドが与えられて、古いクライアントはすでにいらないものも含めてすべてのデータフィールドを受け取ることになります。そのことで、ペイロードが大きくなりすぎて、レイテンシーも拡大することになります。

#### RPC vs REST

* [もとドキュメントの比較リストを参照のこと](https://github.com/donnemartin/system-design-primer/blob/master/README-ja.md#rpc%E3%81%A8rest%E6%AF%94%E8%BC%83)

#### RESTに関する参考文献

* [REST APIとは何ですか？他のタイプとどのように異なりますか？](https://appmaster.io/ja/blog/rest-apitohahe-desuka-ta-notaiputodonoyouniyi-narimasuka)
* [REST APIとは](https://www.redhat.com/ja/topics/api/what-is-a-rest-api)
* [HTTPヘッダをよく知る](https://github.com/for-GET/know-your-http-well/blob/master/headers.md)
* [Wikipediaの記事](https://ja.wikipedia.org/wiki/Representational_State_Transfer)

* [Do you really know why you prefer REST over RPC?](https://apihandyman.io/do-you-really-know-why-you-prefer-rest-over-rpc/)
* [When are RPC-ish approaches more appropriate than REST?](https://softwareengineering.stackexchange.com/questions/181176/when-are-rpc-ish-approaches-more-appropriate-than-rest/181186#181186)
* [REST vs JSON-RPC?](https://stackoverflow.com/questions/15056878/rest-vs-json-rpc)
* [What are the drawbacks of using RESTful APIs?](https://www.quora.com/What-are-the-drawbacks-of-using-RESTful-APIs)
* [Crack the System Design Interview](https://tianpan.co/notes/2016-02-13-crack-the-system-design-interview)
* [Under the Hood: Building and open-sourcing fbthrift](https://engineering.fb.com/2014/02/20/open-source/under-the-hood-building-and-open-sourcing-fbthrift/)
* [Why REST for internal use and not RPC?](https://arstechnica.com/civis/viewtopic.php?t=1190508)

## セキュリティ

この項目は多大になるが、セキュリティに特化した部署・案件に携わらなければ基本的な知識で問題ない

* 情報伝達・保存の暗号化
* XSSやSQL Injectionを防ぐためのユーザ入力情報のサニタイズ
* SQL Injectionを防ぐためのクエリパラメータ化
* 権限最小(least privilege)の原理

### セキュリティに関する参考文献

* [A practical security guide for web developers](https://github.com/FallibleInc/security-guide-for-developers)
* [OWASP Top Ten](https://owasp.org/www-project-top-ten/)

## 補遺

### 役に立つ情報

* [2の乗数表](https://ja.wikipedia.org/wiki/2%E3%81%AE%E5%86%AA)
* [すべてのプログラマーが知るべきレイテンシ値](https://github.com/donnemartin/system-design-primer/blob/master/README-ja.md#%E5%85%A8%E3%81%A6%E3%81%AE%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9E%E3%83%BC%E3%81%8C%E7%9F%A5%E3%82%8B%E3%81%B9%E3%81%8D%E3%83%AC%E3%82%A4%E3%83%86%E3%83%B3%E3%82%B7%E3%83%BC%E5%80%A4)
* [他のシステム設計面接問題](https://github.com/donnemartin/system-design-primer/blob/master/README-ja.md#%E4%BB%96%E3%81%AE%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E8%A8%AD%E8%A8%88%E9%9D%A2%E6%8E%A5%E4%BE%8B%E9%A1%8C)
* [実世界のアーキテクチャ](https://github.com/donnemartin/system-design-primer/blob/master/README-ja.md#%E5%AE%9F%E4%B8%96%E7%95%8C%E3%81%AE%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3)
* [各企業のアーキテクチャ](https://github.com/donnemartin/system-design-primer/blob/master/README-ja.md#%E5%90%84%E4%BC%81%E6%A5%AD%E3%81%AE%E3%82%A2%E3%83%BC%E3%82%AD%E3%83%86%E3%82%AF%E3%83%81%E3%83%A3)
* [企業のエンジニアブログ](https://github.com/donnemartin/system-design-primer/blob/master/README-ja.md#%E4%BC%81%E6%A5%AD%E3%81%AE%E3%82%A8%E3%83%B3%E3%82%B8%E3%83%8B%E3%82%A2%E3%83%96%E3%83%AD%E3%82%B0)
  * 日本のテック企業エンジニアブログ(リンク集)
    * [【保存版】厳選39個のテックブログを独自評価！スキルUP効果も！](https://www.bold.ne.jp/engineer-club/tech-blog)
    * [【保存版】Webエンジニアが見るべきテックブログ一覧](https://creive.me/archives/8596/)
    * [開発者（技術）ブログとは？実例10サイト紹介](https://tcd-theme.com/2022/04/developers-blog.html)
    * [Zenn 【まとめ】テックBlog集](https://zenn.dev/en2enzo2/articles/4ffe5bb74c4a79)
    * [Colorful Palette Tech Note](https://media.colorfulpalette.co.jp/m/m753f507dae79/hashtag/632197)
