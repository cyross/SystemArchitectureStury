# 大規模システム設計メモ（「システム設計入門」を読んで考える）

2022.9 Cyross Makoto

---

## 前提

このドキュメントではテック企業で受ける設計技術面接に対応する教科書として用意されている

## (大規模)システム設計とは？

* 「**スケーラブルなシステム**」を設計すること

### スケーラブルとは？

* システムの規模を**拡大縮小しやすい**こと
  * 大きな変更を加えることなく、システムの増強や縮小を滞りなく行えることを指す
    * 完成したあとでも、顧客の要望や状況によってシステムの拡縮を執り行えるシステムを設計すること
  * 最近、クラウドが流行しているのは、システムの拡縮をソフトウェアレベルで設計・実装できることが強み

## スケーラブルを実現するために想定することと聞き出すこと

システムの背景を質問して聞き出す(要件定義)

### 1.誰がシステムを使うのか？(ユーザ想定)

* 対象ユーザ
  * BtoB？
  * BtoC？
  * BtoBtoC？
  * CtoC？

### 2.どのようにシステムを使うのか？(ユーザ想定)

* 処理の優先順位がわかる
* 汎用の端末を介して？
  * ブラウザを介して？
    * (スマホ・タブレット)アプリを介して？
  * 専用の端末・装置を介して？
    * IoT機器を介して
  * 権限管理
    * RBAC: Role-Based Access Control
      * ユーザーの役割によって権限のチェックを行う
        * 一般ユーザ、管理者など
        * メリット；権限を変更するだけで処理を変えることができる
        * デメリット：権限が増えると管理や実装が難しくなる
    * ABAC: Attribute-Based Access Control
      * ユーザーの属性によって権限のチェックを行う
      * メリット：柔軟な権限管理ができる
      * デメリット：権限チェックが増えると、DBアクセスに時間がかかることがある
　　→属性をグルーピングして役割とする
　　　・AWSのIAMはこのような管理方法
　　　　・更に、IAMユーザ視点だけではなくコンポーネント視点での権限・役割も存在する
　　・https://applis.io/posts/how-to-manage-authorization

### 3.何人のユーザが居るのか？(システムの規模)

* 100人単位？
* 1万人単位？

### 4.システムはどのような機能を持つのか？

* (あとで書く)

### 5. システムの入力と出力は？(

* IoTを使う？

### 6. どれだけの容量のデータを捌く必要があるのか？

### 7. 1秒間に何回アクセスが有るのか？(スループットの推定)

* アクセスが集中する時間帯や時期を確認
* いちばんアクセスする値(推定)がほしい
* いちばん空いている値もほしい(拡縮の判断)

### 8. 読み書き比率はいくらなのか(推定値)？

* (あとで書く)

## おさらい

### 動画でおさらい

[ハーバード大学の講義の動画(英語)](https://www.youtube.com/watch?v=-W9F__D3oY4)

#### 語られている項目

* 垂直スケーリング
* 水平スケーリング
* キャッシング
* ロードバランシング
* データベースレプリケーション
* データベースパーティション

### ブログ記事でおさらい

[Le Could Blogのscalabilityタグ](https://www.lecloud.net/tagged/scalability)

#### 語られている項目

* クローン
  * ロードバランサの下のサーバはそれぞれ全く同じコード内容(コードベース)、同じ出力ができるのが必須
  * ロードバランサはリクエストを均等に割り振るため、どのサーバで処理するのか予測不可能
    * ユーザ関連データはサーバに置かない。サーバからアクセスできるDBに格納する
      * サーバにこれらのデータを置くと整合が必要
  * セッションは持続可能キャッシュ(Redisとか)を使う
    * 外部DBを使うよりも反応が良い
  * RailsだったらCapistranoでクローン時のコードベースを担保
    * AWSのAIMも同じように担保できるのでクローンに有効
    * 水平スケーリングの核
* データベース
  * データベース設計の肝は「非正規化」
    * クエリレベルでの結合をなるべく避ける
    * 結合が必要になったらアプリケーションレベルで行う
      * その際には使用するデータをなるべく最適化
    * 更に規模が大きくなると、それでも遅くなるのでキャッシュを導入
      * RedisとかMemcachedとか
      * Redisは柔軟な設計が可能、Memcachedは垂直スケーリングができる
      * [参考:AWS公式のRedis・Memcached比較ページ](https://aws.amazon.com/jp/elasticache/redis-vs-memcached/)
    * NoSQLの導入
      * スケーリングに強いシステムに切り替えることも考慮
  * 場合によってはデータベースレプリケーションやデータベースパーティションも考慮
* キャッシュ
  * RedisやMemcachedの導入
    * メモリ内キャッシュが必須、ファイルキャッシュはNG
      * ファイルキャッシュを使用すると自動スケーリングやサーバーのクローニングが面倒になる
      * アプリケーションとデータベースとの間のレイヤーに存在する
      * アプリを開発するときはまずキャッシュにフェッチ、見つからなかったらDBにアクセス
    * メモリ内キャッシュは超高速
　　・キャッシュの持ち方、取り出し方は２種類
　　　・キャッシュされたクエリ
　　　　・キャッシュのキーとしてハッシュバージョンを使用
　　　　・複雑なクエリをキャッシュすると削除しにくくなる
　　　　・セルの中身が変わった時、そのセルに関わるキャッシュを全て削除する必要がある
　　　　　・セルにかかわるキャッシュをすべて洗い出すのが面倒
　　　・キャッシュされたオブジェクト
　　　　・複数のデータを纏めてオブジェクトと認識、キャッシュすれば効率的に
　　　　・キャッシュするオブジェクトの例
　　　　　・セッション(DBには保存しないで！)
　　　　　・ブログデータ
　　　　　・アクティビティストリーム
　　　　　・ユーザーとフレンドの関係
　・非同期
　　・常に時間のかかる処理は非同期で処理する
　　　・#1：リクエストの結果がほぼ固定の場合は、事前に時間のかかる処理を施し、リクエストがあったときに短時間で返す
　　　　・処理を施すタイミングは一定時間の間隔で定期処理を施す
　　　・#2：リクエストの結果が流動的なときや突発的なときは、処理の開始をキューに投げてその旨をユーザーに通知する
　　　　・フロントエンド側では完了をチェックして、完了を受け取ったらユーザーに通知する(結果を返す)
　　　・RabbitMQのチュートリアルは非同期のケーススタディの参考になる
　　　　・メッセージブローカーの一種
　　　　　・システム間の依存性をなくす
　　　　・PtoPにもなるし、Pub/Subもいける
　　　　・他には、ActiveMQ(AmazonMQ)がある。Redisもメッセージブローカーとして使える

## ハイレベルでのトレードオフ

### トレードオフのパターン

パターンとして以下の３つがある

* パフォーマンス vs スケーラビリティ
* レイテンシ vs スループット
* 可用性 vs 一貫性

### パフォーマンス vs スケーラビリティ

* パフォーマンスが上がる→処理速度が上がる、もっと大きなデータを捌ける
* 水平にスケールしていけば、そのぶん処理が最適化されると思っていたら大間違い

### レイテンシ vs スループット

#### レイテンシ

何かのタスクを実行する・結果を出すのにかかる時間

一気に多数のタスクが来ると遅延する可能性がある

#### スループット

単位時間内にタスクを実行したり結果を出せる回数

#### レイテンシとスループットとの駆け引き

スループットを最大化するためにレイテンシをどれだけ受け入れられるか

* レイテンシを極限まで削っても、得られる結果が不十分(情報量が少ない、間違っているなど)では不適当
* しっかりした結果を出せたらスループットは犠牲になってもいいのか？
* そこのバーターが腕の見せ所

### 可用性 vs 一貫性

#### CAP理論

システムを設計する方向性を検討する際、以下の3つのうち、せいぜい2つまでしか担保できないという理論

* 一貫性(Consistency)
* 可用性(Availability)
* 分断耐性(Partition tolerance)

##### 一貫性

すべての読み込みは、最新の書き込みかエラーを受け取る設計
外側から見たデータがすべて同じデータに見える状態に置く設計

一貫性は結果の新しさに応じて強さを決める

* **弱い**：結果を返すときは最新かどうかはわからない(更新されないときがある)
  * memcachedでよく見られる
  * 例: ビデオチャット、マルチプレイヤーゲーム、VoIP
* **結果整合性**：結果を返すときは、タイミング的には最新ではないかもしれないけど、最終的には最新になる
  * 例: メールシステム、DNS
* **強い**：結果を返すときは必ず最新を保証する
  * 例: ファイルシステム、トランザクションを使うシステム
  * 補足として、ACID特性も追記した(後述)

###### 一貫性の利点

* 無駄なデータ変換を噛ませる必要がない
* 矛盾を生じにくい
  * 一貫性を損なうモジュールを追加した際にはバグが起こりやすい
  * 最新の標準的なライブラリをなるべく使う(流儀に従う)
* 設計の間違いに気づきやすい

##### 可用性

受け取る情報が最新という保証がないが、リクエストすれば必ず結果を受け取れる設計。もしくは、データを利用したいときに利用できる状態に置く設計（信頼できるデータを長い間利用できる設計）
こうすることで、システムの運用を長く続けられる性質。

###### フェイルオーバー

稼働中にシステムがダウンした際、自動的に待機しているシステムが後を引き継ぐ仕組み

フェイルオーバーを考慮したシステムの構成は以下の2パターンがある

* **アクティブ・パッシブフェイルオーバー(マスター・スレーブフェイルオーバー)**
  * システムを利用している側が周期的に信号をアクティブもしくはパッシブ(スタンバイ)に送る
  * 信号が中断された際はパッシブのスタンバイを時、アクティブになる
    * ダウンタイムが必要
  * 例: MongoDBの単一マスター制により、分散されているDB上のデータはすべて最新

* **アクティブ・アクティブフェイルオーバー**
  * すべてのシステムが処理を捌く(負荷分散)
  * 問題が起きたシステムはパッシブになる
    * ダウンした際にパッシブに共有していないデータが存在するリスクがある
  * 例: Cassandraはすべてアクティブ(アクティブ・アクティブフェイルオーバー)

###### レプリケーション

マスター側がスレーブ側に最新の情報を伝達して同一を保持する仕組み

##### 分断耐性

ネットワークが何らかの原因で分断されてもシステムは正常に動く設計。つまり、分断されたほうにあるシステムにリクエストが行かないよう確実に遮断する設計

##### 完全に達成できる組み合わせ

CAPのうち、完全に同時に達成できるのはせいぜい２つまでで、その組み合わせは**CP**と**AP**のみ。
Pは必ず受け入れる必要がある(ネットワークは絶対の信頼を置けないから)

* **CP**: 不可分操作(複数の操作を組み合わせて一つの操作とする)
* **AP**: 結果総合性を受け入れるとき、外部エラーが起きても稼働する必要がある時はAPで設計

**注**: ただし、相反している、つまりゼロイチの話ではなく、一貫性を保ちながら可用性を最大限に引き上げる、もしくはその逆はできる

* 「一貫性を受け入れる」か、「可用性を受け入れる」か、それが運命の分かれ道
* とはいえ、両方受け入れられないのか？　矛盾しているのか？？？
  * 弱点を補強するBASE理論が提唱された(後述)
* CAPの提唱者も言っているが、CとAのどちらに全振りするか、という極端な話ではない点に注意すること

#### 補足1: BASE理論

CAPの弱点を補う形でデータの整合性を取る理論
以下の3要素を採用している

* 基本的な可用性(Basically Available)
* 耐久性のない状態保持(Soft-State)
* 結果整合性(Eventually Consistent)

結果整合性は既出なので説明は省略する

他のリクエストに影響を出さないように務めるトランザクションには向かない(後述するACID特性を遵守するため)

##### 基本的な可用性

可用性を考える時、フェイルセーフなどを用いることになるが、基本的なもので賄うことで可用性を担保する

###### 楽観ロック

同時にデータを更新するのは無いだろうという楽観的な視点で対応する(自分さえ良ければそれでいい的なイメージ)

更新する際は、更新前の値が取得時の値と変わって居ないかどうかを確認するだけで、データが追加されたり、実際に他のリクエストがデータにアクセスしていないことを考慮しない。

逆に、悲観ロックは、誰かがアクセスしている間更新できないロック

###### キュー

(略)

##### 耐久性のない状態保持

いつリクエストしてもそこにデータが存在しているわけではなく、時と場合によっては存在していない
ちなみに、状態とは**データの状態**を指す

外部データを使用することで保証する

外部データはHard-State(耐久性のある状態保持、ファイルなど)のシステムがマスト

Soft-Stateの例としては、キャッシュがまさにそれ

#### 補足2:ACID特性

トランザクション処理における絶対不可欠な要素４種類の頭文字を指す

* 不可分性(Atomicity)
* 一貫性(Consistency)
* 独立性(Isolation)
* 永続性(Durability)

一貫性は既出なので省略する

##### 不可分性

実行対象が完全に結果を残す(全く結果を残さない)ことを保証する

* 確実にCommitかRollbackされる
* 中途半端に結果を残さない

##### 独立性

トランザクション実行中に他のリクエストがデータへアクセスに制限を設ける(分離する)ことを保証すること
アクセス制限の度合いは設定可能(分離レベル)。ただし、強力なものになるにつれてパフォーマンスに影響が出たり、デッドロックが発生することに注意。
(ちなみに、テーブル自体をロックする方法も検討する)

###### リード現象(Read Phenomena)

トランザクション実行時のデータ整合性の問題が生まれる。これをリード現象(Read Phenomena)と呼ぶ。これは分離レベルを用いることでこれらの現象を解決できる。

* **Dirty Read**

トランザクション実行中に、別トランザクションが更新している(未Commit)のデータを読み込める

* **Fuzzy Read(Non-Repeatable Read)**

繰り返し同じデータを読み込むトランザクション実行中に、別トランザクションが更新・Commitした値を読み取る

* **Fantom Read**

トランザクション実行中に、別のトランザクションがデータを追加・Commitして変更された値を読み取る

* **Lost Update**

トランザクションが更新したデータを、別のトランザクションが更新したために更新がなかったことにされた

###### 分離レベル

分離レベルの例としてANSIが制定しているものを解説していく
設定によって解決できるリード現象の範囲が違う

* **read uncommitted**

未Commitのデータでも読み込める。
処理は早くなるが、Dirty Readのリスクは高い。

* **read committed**

更新されたCommitのみ参照できる(最後に更新Commitした値を参照する)。ただし、追加・削除に関しては未Commitのデータも参照できる
Dirty Readは解消できるがFuzzy ReadやFantom Readは対処できない。

PostgreSQL,SQLServerでの標準分離レベル。

* **repeatable read**

Commitされた更新・追加・削除のデータのみ参照できる(トランザクション中に同じ参照をした際は、最後にCommitしたデータを参照する)。
ただし、整合性が取れるが一貫性は担保できない。
Fuzzy Read・Fantom Readも解消できるが、Lost Updateは流石に対策しないと避けられない。

MySQLでの標準分離レベル。

* **serializable**

強制的にトランザクションの順番をつけて、同時実行をさせないようにする。
Lost Updateもなくなるが、スループットは大幅に悪くなる。

* **その他**

IBM DB2には「カーソル固定」というものがある

##### 永続性

障害によって起きるデータの損失を出さないようにする。まずはインフラ側で障害をおこなさないようにするのはマストだが、どうしようもない時があることは受け入れる。

ログが取れなかったときのリスクも検討する。
トランザクション・クエリのログを取っておく。
障害が起きて消えたデータをそのログで復帰させる。

### 実例で学ぶトレードオフ

トレードオフの例として、以下のシステムを解説する。

* DNS(Domain Name System)
* CDN(Content Delivery Network)
* ロードバランサ
* リバースプロキシ(Webサーバー)
  
#### DNS

ドメイン名からIPを割り出す。階層構造になっており、下層のDNSはキャシュを用いて高速化を測っている。それゆえ、割り出す組み合わせが変わっているにも関わらず、DNSに反映されていなかったりキャッシュを返したりする時がある。
しかも、キャッシュされていたとしても、やはり取得に少しの時間が必要。

DNSを使用した負荷分散も可能(メリットデメリットが有る)

* **加重ラウンドロビン(重み付きラウンドロビン)**

サーバーの処理能力に応じて、管理者が明示的に「重み」を設定し、その重みに応じた分量を割り振る。
例えば、インスタンスXに80、インスタンスYに20を割り振れば、40個のリクエストのうちXには32個、Yには8個割り振られる。
IPが指しているシステムに障害があったとしても検知できないなどの問題がある。

* **レイテンシベースルーティング**

リクエストのレイテンシを測定して、レイテンシが一番短い地域のIPアドレスを返す方式

* **物理ベースルーティング**

詳細不明

##### DNSの弱点

DNSサーバの管理が複雑(大企業や政府によって管理されている)
更に、DDoS攻撃の標的になる危険性がある(Twitterの障害が例)

##### DNSで登録する内容

* NS record (name server) - あなたのドメイン・サブドメインでのDNSサーバーを特定します。
* MX record (mail exchange) - メッセージを受け取るメールサーバーを特定します。
* A record (address) - IPアドレスに名前をつけます。
* CNAME (canonical) - 他の名前もしくは　CNAME (example.com を www.example.com) もしくは A recordへと名前を指し示す。

#### CDN

世界中に設置されたプロキシーサーバーがリクエストしたデータを返す(HTML、CSS、JS、画像、動画などの静的データ)。
特徴的なのは、リクエストした場所から一番近いプロキシーサーバーがデータを返すこと。故に、CDNサーバーが元のサーバーからデータを取得させる必要がある。

例外はAWSのCloudFrontで、動的なデータも提供可能

取得方法は次の2種類

##### プッシュCDN

管理者がすべてのCDNにデータをアップロードし、URLがCDNを指すようにすることで、リクエスト側が最新のデータをすぐに受け取れることを担保する方式（データの責任は管理者に委ねられる）。
データアップロードに手間がかかることと、すべてのCDNにデータが置かれることからストレージの負担も難点

→あまりトラフィック量や更新頻度が低いデータに向いている

#### プルCDN

データ自体は元サーバーに存在し、CDNにリクエストが来る際に元サーバーのデータをキャッシュする方式
CDNが取ってきたデータの有効期間を設定可能
ストレージの無駄は省けるが、初回リクエストのときに時間がかかること、最新のデータの反映が遅くなることが難点

→トラフィック量が多かったり、頻繁に更新されるデータに向いている

### CDNの弱点

CDNのトラフィック量によってコストが変わる。CDNを使わないときも考慮に入れる必要がある。
また、リクエスト側(HTMLやJS、CSS)側でCDNを明示的に指し示す必要がある。

#### ロードバランサ

各サーバーの冗長化のために、ルールに則って複数サーバーに負担を強いることなくリクエストを振り分けるサーバー

基本的に以下の効果がある。

* リクエストが状態の良くないサーバーに行くのを防ぐ
* リクエストを過剰に送るのを防ぐ
* 特定箇所の欠陥でサービスが落ちることを防ぐ

他にも、SSLを使った暗号化・復号化を肩代わりしたり、セッション管理やコンテンツキャッシュなどの機能を持つサーバーアプリがある。

HAProxyなどを使って実現する。

##### 振り分けのルール

振り分けのルールには以下のものがある。

* **ランダム**
  * どんなリクエストが来ようとも、乱数で行き先を割り振る
* **Least Loaded**
  * 各サーバーが受け持っている処理数を確認して、一番空いているサーバーに割り振る
* **セッション/クッキー**
  * セッションが保存された場合、そのIDでリクエストを割り振る
  * クッキーにセッション情報を組み込むことで維持する
* **ラウンドロビン、加重ラウンドロビン**
  * リクエストの振り分け先を順番に振り分ける
  * 加重ラウンドロビンは既出のため省略
* **Layer4**
  * トランスポート層（OSI参照モデル第4層）の情報をもとに振り分ける
  * リクエストのソースIP、送信先IP、ヘッダのポート番号
* **Layer7**
  * アプリケーション層（OSI参照モデル第7層）の情報をもとに振り分ける
  * リクエストのコンテンツ（ヘッダ、メッセージ、クッキー）、リクエストパラメーター

##### 利点

水平スケーリングする際に、外側からのアクセスへの考慮負担が少なくなる。パフォーマンスと可用性が向上する。

ただし、データの一貫性は考慮する必要があるし、上層サーバーをスケールアウトすれば、そのぶん、下部サーバーのスケールも上げる必要がある

##### 弱点

特徴ゆえか、単一障害点になりやすいのが一番の弱点。
そのため、フェイルオーバーを施すのはほぼマスト。
しかし、フェイルオーバーを施すと構成が複雑になってしまう。

#### リバースプロキシ
